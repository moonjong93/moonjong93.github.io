<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-08-01T14:31:26+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">종민</title><subtitle>개발로그 및 일상</subtitle><entry><title type="html">심심한 블로그 2.0</title><link href="http://localhost:4000/%EA%B0%9C%EB%B0%9C/rebuild-blog/" rel="alternate" type="text/html" title="심심한 블로그 2.0" /><published>2023-03-09T00:00:00+09:00</published><updated>2023-03-09T00:00:00+09:00</updated><id>http://localhost:4000/%EA%B0%9C%EB%B0%9C/rebuild-blog</id><content type="html" xml:base="http://localhost:4000/%EA%B0%9C%EB%B0%9C/rebuild-blog/"><![CDATA[<h2 id="블로그를-개편하자">블로그를 개편하자</h2>

<p>오래되고 오래되었다… 중간에 잠깐 그냥 노션에 하면 어떨까? 했지만 방문자 추적도 안되고 무엇보다 검색에 허용도 안되고.. 사실 재미도 없다. 그런 이유로 블로그를 개편해보자.</p>

<h2 id="문제점">문제점</h2>

<h3 id="1-쓸데없는-정보들">1. 쓸데없는 정보들</h3>

<p>글을 쓰기 위해 블로그에 설정해야할게 너무 많다.</p>

<ol>
  <li>타이틀</li>
  <li>설명</li>
  <li>태그</li>
  <li>카테고리</li>
  <li>코멘트 여부</li>
  <li>퍼머링크</li>
  <li>작성 일자
위의 목록만해도 총 7줄이 넘어가는데 사실 title말고 필요한 정보가 있을까? 아니 없다고 봐도 무방하다.</li>
</ol>

<h3 id="2-글도-몇개-없는데-쓸데없이-있는-페이져">2. 글도 몇개 없는데 쓸데없이 있는 페이져</h3>

<p>그땐 페이져가 있어야 했을것 같았다 5년전만해도 이게 뭔가 멋있어 보였달까? 근데 어차피 잘 들어오지도 않는 페이지에 이게 무슨 낭비람? 내가 평생 글을써도 500개 미만일텐데 굳이 이렇게 할필요가 있나 싶다. 그땐 이거 만들어보려고 지킬에서 엄청나게 고민하면서 문서를 찾았었는데</p>

<h2 id="todo-list">TODO List!</h2>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />블로그 디자인 변경</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />페이지네이션 없애기</li>
</ul>]]></content><author><name></name></author><category term="개발" /><summary type="html"><![CDATA[블로그를 개편하자]]></summary></entry><entry><title type="html">그리드에 편집 기능 끼얹기</title><link href="http://localhost:4000/development/blog/added-edit-mode-on-grid" rel="alternate" type="text/html" title="그리드에 편집 기능 끼얹기" /><published>2023-03-02T00:00:00+09:00</published><updated>2023-03-02T00:00:00+09:00</updated><id>http://localhost:4000/development/blog/added-edit-mode-on-grid</id><content type="html" xml:base="http://localhost:4000/development/blog/added-edit-mode-on-grid"><![CDATA[<h2 id="목차">목차</h2>

<ol>
  <li>왜 필요한가?</li>
  <li>필요한 기능
    <ul>
      <li>복사 후 붙여넣기 (테이블과 같은 정형 데이터는 ,등으로 분류)</li>
      <li>하나의 셀 편집 기능</li>
    </ul>
  </li>
  <li>어떻게 구현했는지?
    <ul>
      <li>복사 후 붙여넣기
        <ul>
          <li>붙여넣기 한 text를 , 또는 \t 단위로 잘라냄 개행은 \n</li>
        </ul>
      </li>
      <li>편집기능
        <ul>
          <li>가지고 있는 Position에 TextInput 끼어넣기</li>
        </ul>
      </li>
      <li>원본데이터 업데이트 및 컴포넌트 사용하는 곳에 업데이트 알림
        <ul>
          <li>javascript의 깊은 복사와… 얇은 복사의 슬픔</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이때와 지금과 다른점
    <ul>
      <li>map을 사용하면 어떨까?</li>
    </ul>
  </li>
</ol>

<h3 id="왜-필요한가">왜 필요한가?</h3>

<p>JDBC로 mariaDB 또는 mysql의 데이터베이스 연결 후 데이터를 추가하거나 업데이트하는 일이 필요해졌다. 그 데이터의 양이 1개 2개 라면 상관없지만 적게는 100개 많게는 10,000개 이상의 데이터를 데이터베이스에 직접 적재하는 과정이 필요했고 이 데이터를 클라이언트에서 추가해서 배열 형식으로 보내주면 서버는 이를받아 데이터베이스에 직접 추가하는 방식이었다.</p>

<h3 id="필요한-기능">필요한 기능</h3>

<p><strong>선행기능</strong></p>

<ul>
  <li>셀 선택 기능
    <ul>
      <li>붙여넣거나 편집할 위치를 알기 위해 선택하는 셀 자체의 위치를 알아야한다.</li>
    </ul>
  </li>
  <li>드래그 선택
    <ul>
      <li>드래그 한 영역의 범위를 알아야 선택된 영역의 범위를 덮을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><strong>아무</strong> <strong>웹사이트 내의 있는 테이블 데이터를 복사 할 수 있어야 했다.</strong></p>

<p>테이블은 \t, \n, \, 등으로 개행 등을 구분한다.</p>

<ul>
  <li>\n은 하나의 배열 공간을 차지하고</li>
  <li>\t는 하나의 컬럼값의 해당하므로 객체안의 데이터이다</li>
  <li>\,은 오브젝트안의 값이다.</li>
</ul>

<p><strong>편집기능은 쉬워야 한다.</strong></p>

<ul>
  <li>사용자의 특정 키 입력에 따라 수정 모드로 진입, 나가기 할 수 있어야한다.
    <ul>
      <li>enter, esc 등</li>
      <li>알파벳의 키코드</li>
    </ul>
  </li>
</ul>

<p><strong>원본 데이터를 업데이트 및 컴포넌트 사용자가 알아야 한다.</strong></p>

<ul>
  <li>편집시 변경 점을 알려주어야 함</li>
</ul>

<h3 id="구현을-하며-문제점">구현을 하며 문제점</h3>

<ul>
  <li>javascript의 복사는 주소만 카피하므로 변경 데이터를 비교하는데 어려움이 있다.</li>
  <li>한글의 자모음이 끝나는 부분에서 enter키의 타이밍은 영문과 다르다.</li>
</ul>

<h3 id="이때의-코드를-변경하고-싶은것">이때의 코드를 변경하고 싶은것</h3>

<ul>
  <li>그냥 javascript의 map을 사용했다면 어떨까?</li>
</ul>]]></content><author><name></name></author><category term="개발" /><category term="grid" /><category term="typescript" /><summary type="html"><![CDATA[목차]]></summary></entry><entry><title type="html">어떤 컴포넌트가 사용하기 편헐까?</title><link href="http://localhost:4000/development/blog/what-components-easy-use" rel="alternate" type="text/html" title="어떤 컴포넌트가 사용하기 편헐까?" /><published>2022-12-20T00:00:00+09:00</published><updated>2022-12-20T00:00:00+09:00</updated><id>http://localhost:4000/development/blog/what-components-easy-use</id><content type="html" xml:base="http://localhost:4000/development/blog/what-components-easy-use"><![CDATA[<p>회사에서 angular-sdk를 맡아서 공통적으로 사용하는 컴포넌트를 sdk화 시키는 작업을 맡은지 1년이 좀 넘었다. 그동안 회사에서 사용하는 컴포넌트들을 리빌딩하면서 느낀점을 적어보려고 한다.</p>

<ol>
  <li>이것도 있으면 편하겠지?</li>
  <li>사용자가 사용할때 굳이 위에서 두번 타입을 바꿀 필요 없게 하면 쓰기 더 편하지 않을까?</li>
</ol>

<p>위의 얘기를 몇가지의 사례를 가지고</p>

<h2 id="이것도-있으면-편하겠지">이것도 있으면 편하겠지?</h2>

<p>컴포넌트를 만들다보면 이런저런 많은 기능이 들어가는 경우가 수두룩 했었다. 특히 그리드에선 그랬는데 <code>virtaul scroll</code> 기능을 추가한 그리드라는 얘기가 무성할 정도로 결국은 많은 기능이 필요했었다. 기억에 남는 몇개의 기능을 얘기해보자면</p>

<ol>
  <li>IP 국기 플래그 추가</li>
  <li>너비 조절 사용자 지정(너비 지정한 것을 저장하여야 함)</li>
  <li>컬럼 드롭다운 사용자 지정</li>
</ol>

<p>등의 기능이 있었는데 이 기능을 추가하기 위해 <code>컴포넌트 내부</code> 에서 몇가지 작업이 필요했었다. 가령 ip 국기를 추가하기 위해서 ip-table을 탐색해서 확인해야하고 이 로직이 그리드 자체에 들어간것이다.</p>

<p>애초에 이 그리드는 <code>가상 스크롤</code>주제를 가지고 시작한 그리드이다. 근데 이 그리드에서 기능이 여러가지 필요해서 붙이다보니 이벤트 부터 시작해서 <code>총 12개의 파일</code>로 구성된 그리드가 되어버린 것이다.</p>

<p>이렇게 했을때 문제는 다음과 같다.</p>

<ol>
  <li>컴포넌트의 새로운 기능이 추가될때마다 점점 하나의 컴포넌트가 가져야할 코드가 많아짐</li>
  <li>당연히 유지보수 어려움</li>
  <li>코드가 길어짐에 따라서 <code>본연</code>의 기능인 가상 스크롤 기능을 확실히 체크하기 어려움 (QA쪽에도 부하가..)</li>
</ol>

<p>그렇다면 어떻게 했어야 했을까?</p>

<h3 id="컴포넌트는-그-자체로-둬야-아름답다">컴포넌트는 그 자체로 둬야 아름답다</h3>

<p>컴포넌트는 그 자체로 두어야 한다. <code>가상화 스크롤</code> 이라는 기능에 촛점을 맞췄다면 그것을 만들면 그만인것이다. 그렇지만 항상 기능이 이것저것 따라온다면 아래와 같이 문제를 풀어야 할것이다.</p>

<ul>
  <li>가상화 스크롤에 들어간 row의 dom을 직접 template기능으로 줄 수 있으면 될것 (이후에는 필요한 기능을 확장해서 사용)</li>
  <li>너비 조절시 이벤트로 너비 조절된 데이터를 전달</li>
</ul>

<p>위와 같이 스크롤 기능을 제외하고 특별한 기능이 필요하다면 그에 필요한 <code>재료</code> 를 전달하면 된다. 그렇게되면 특정한 상황에서도 큰 변화 없이 컴포넌트는 <code>유지</code> 될 수 있다.</p>

<h2 id="select-컴포넌트로-보는-사용자-친화-적인-개발이-오히려-불편함을-가져다-준-경우">select 컴포넌트로 보는 사용자 친화? 적인 개발이 오히려 불편함을 가져다 준 경우</h2>

<p>어느날 우리 회사 제품에 select 컴포넌트가 필요해졌다. SDK에서 받아야 할 프로퍼티는 아래와 같았다.</p>

<ul>
  <li>보여줘야 할 목록의 이름</li>
  <li>어떤게 선택되었는지 보낼 이벤트</li>
</ul>

<p>이렇게 사용하는 컴포넌트였는데. (검색 기능 등 이런것은 제외하고)</p>

<p>아래와 같이 프로퍼티를 받았다.</p>

<pre><code class="language-tsx">type SelectItems&lt;T&gt; = {
  name: string;
  value: T;
}[];
</code></pre>

<p>그리고 이벤트의 타입은 아래와 같았다</p>

<pre><code class="language-tsx">type ItemChangeEvent&lt;T&gt; = {
  value: T;
};
</code></pre>

<p>클릭을 하면 value를 직접 보내주는건데 이렇게 보면 어떤게 문제가 되는지 잘 이해하기 어렵지만.. 왜 굳이 이벤트와 아이템 프로퍼티가 다른지에 대한 설명을 해보자면</p>

<p>내가 원하는 select 컴포넌트는 어떤 배열을 보내던간에 name 프로퍼티에 대한 키를 보내고 (이때 name에 대한 프로퍼티를 새로 받음) value에 대한 키를 보내고 이 키를 가지고 아무 배열 형태의 데이터를 가져오더래도 이를 표시해주기 위함이었다.</p>

<p>즉 사용하기 편하게 하기위해 여러가지 프로퍼티를 받아야 했었는데. 이를 가지고 회사 외부에서 SDK관련 교육을 할때 가장 많이 받은 질문이 이거였다.</p>

<blockquote>
  <p>Select가 아무것도 안보여요..</p>
</blockquote>

<p>그래서 나는 대답했다 문서를 보시면 이렇게 받아서 이렇게 보고…..</p>

<p>이 대답과 정확한 select 사용방법을 설명해주기 위해서 SDK 교육의 5분정도를 할애했다는 것이다. 나에게 주어진 시간은 약 2시간이었는데 상당히 긴 시간이었다.</p>

<p>그렇다 이 select 컴포넌트는 이 코드를 잘아는 <code>내부</code> 개발자만 사용하기 편하다는 것이다… 이 마져도 여러번 문서를 번갈아 가며 봐야 할 때가 많았다.</p>

<hr />

<h3 id="그래서-새로운-select는-어떻게-만들었는가">그래서 새로운 select는 어떻게 만들었는가</h3>

<p>아주 간단하게 만들었다. <code>string[]</code> 타입을 받아서 그대로 드롭다운에 표시하고 그것을 클릭하면 클릭한 index를 전달하는 것이다. 오히려 나도 이렇게 사용해보니.. 이렇게 쓰는게 훨씬 편했다.</p>]]></content><author><name></name></author><category term="개발" /><category term="grid" /><category term="typescript" /><summary type="html"><![CDATA[회사에서 angular-sdk를 맡아서 공통적으로 사용하는 컴포넌트를 sdk화 시키는 작업을 맡은지 1년이 좀 넘었다. 그동안 회사에서 사용하는 컴포넌트들을 리빌딩하면서 느낀점을 적어보려고 한다.]]></summary></entry><entry><title type="html">가상 그리드 만들기</title><link href="http://localhost:4000/development/blog/why-made-grid-with-virtual-scroll" rel="alternate" type="text/html" title="가상 그리드 만들기" /><published>2022-12-20T00:00:00+09:00</published><updated>2022-12-20T00:00:00+09:00</updated><id>http://localhost:4000/development/blog/why-made-grid-with-virtual-scroll</id><content type="html" xml:base="http://localhost:4000/development/blog/why-made-grid-with-virtual-scroll"><![CDATA[<h3 id="데이터-그리드">데이터 그리드</h3>

<p>어떤 데이터를 보여주기 위한 ‘표’ 테이블이라고도 할 수 있다.</p>

<p>내가 일하는 회사 ‘로그프레소’는 많은 ‘로그’나 ‘데이터’ 등을 가공하여 사용자에게 시각화를 통해 해당 로그가 어떤 위험이 있고 어떤 준비를 해야하는지 알려주는 제품이다.</p>

<p>하지만 <code>&lt;table/&gt;</code> 기존 데이터 그리드 방식은 약간 문제가 많았다.</p>

<h2 id="문제점">문제점</h2>

<p>많은 양의 데이터를 보여주면 브라우져가 죽어버리기 때문에 한페이지에 100개의 로우를 담은 페이지만을 보여주어야 한다.</p>

<ol>
  <li>마찬가지로 컬럼이 많은 경우에도 느려지고 특정 사양의 브라우저에서는 아예 꺼지기도 했기 때문에 그런 데이터는 지양하여 담아야 했다.</li>
  <li>좌우 너비가 없이 일단 기본 고정폭인 200px로 렌더링되기 때문에 긴 문장의 경우 사용자가 좌우 너비를 넓혀야 했으며 다시 해당 데이터를 불러와도 해당 너비가 저장이 안되어서 계속해서 마우스 드레그를 통해 늘려야 했다.</li>
</ol>

<h2 id="문제-해결을-위한-기초-지식">문제 해결을 위한 기초 지식</h2>

<ul>
  <li>table은 많은 데이터가 표시되면 느려진다 (일부만 표시되어야 한다) → 가상 스크롤을 적용해야한다.</li>
  <li>브라우저 스펙에 맞는 가상 스크롤 스펙 및 폴리필을 정해야했다.
    <ul>
      <li>처음 개발할 당시에는 IE11을 현역으로 사용하고있는 고객이 많았다.</li>
    </ul>
  </li>
  <li>렌더링하지 않고 해당 ‘셀’의 너비 및 높이를 알기 위해서는 canvas의 <strong><code>measureText</code> 등을 알아야 했다.</strong></li>
</ul>

<h3 id="해결하면서-겪은-삽질">해결하면서 겪은 삽질</h3>

<ul>
  <li>angular에 내장된 virtual scroll은 사용하는곳이 없어 정보찾기도 어렵고 추후 별도의 플랫폼에서 사용할 수 없었다.
    <ul>
      <li>당시 이 기능은 angular, angularJS, react, javascript 등이 혼용된 곳에서 SDK로서 사용할 수 있었어야 했다.</li>
    </ul>
  </li>
  <li><code>span</code>을 보이지 않는곳에 렌더링하고 너비를 가져오는것은 생각보다 큰 비용이 발생했다.
    <ul>
      <li>canvas의 <code>measureText</code> 를 사용해야만 하는 이유가 되었음</li>
    </ul>
  </li>
</ul>

<h3 id="angular-react가-아니라-pure-typescript로-개발한-후-wrapper를-통해-angular-react를-지원하게됐던-이유">angular, react가 아니라 pure Typescript로 개발한 후 wrapper를 통해 angular, react를 지원하게됐던 이유</h3>

<ul>
  <li>회사 내부에는 React를 ‘불신’하는 개발자 분들이 많았다.</li>
  <li>angular의 virtual scroll은 정보가 찾기 힘들었다.</li>
  <li>일반적인 곳에서도 동작이 되어야 했다.</li>
</ul>

<p>위의 이유로 typescript를 통해 개발하게 되었다.</p>

<h2 id="개발">개발</h2>

<h3 id="셀의-개념을-사용한-엑셀-스프레드-시트와-같은-유틸리티로서의-개발이-필요했다">셀의 개념을 사용한 ‘엑셀’, ‘스프레드 시트’와 같은 유틸리티로서의 개발이 필요했다.</h3>

<p>필요한 기능 몇개만 나열해보자면</p>

<ol>
  <li>셀 클릭한 위치에 데이터를 통한 쿼리 진행</li>
  <li>특정 셀의 값이 사용자가 요청한 값의 범위에 들어간다면 색상을 사용자가 원하는 색으로 변경 할 수 있어야 했음 (조건부 서식과 같은?)</li>
  <li><code>editable</code> 기능을 통해 해당 데이터 그리드가 ‘편집’이 가능해야 했다.</li>
  <li>드레그한 셀의 범위 복사 등</li>
</ol>

<p>위와 같은 기능은 스프레드 시트에서 직접 드레그해보고 하면서 어떻게 개발하면 좋겠다고 생각했었다.</p>

<h3 id="간단한-설계부터">간단한 설계부터.</h3>

<p>데이터 스토어는 존재해야한다. body를 담당하는 <code>class TableBody</code>와 head를 담당하는 <code>class TableHead</code>는 데이터에 변형을 가해서는 안됐다.</p>

<p>일단 Redux 패턴을 유심있게 본 결과 내린 결론인데. event가 아닌곳에서 데이터를 변형하면 이 변경이 어디에서 발생했는지 알 수 없으므로 모든 변경은 Event가 store에 전달을해서 변경해야 했다. 이구조를 변경해야 한다면 아예 설계 자체가 틀어지므로 이 부분은 확실히 변경이 없게 해두고 공식 스펙으로 정해두고 개발을 시작했다.</p>

<p>간단히 얘기해 store -&gt; event -&gt; body, head와 같은 컴포넌트로 전달하는 방식이다.</p>

<h3 id="비정형-데이터를-그리드에-표시하기-좋은-데이터로-만들기-위해">비정형 데이터를 그리드에 표시하기 좋은 데이터로 만들기 위해.</h3>

<ul>
  <li>각 셀은 컬럼, 로우의 id를 가지고 있는다. 이후 클릭시 해당 위치를 파악하고 데이터 정제를 하기 쉽게 하기 위함이다. <code>records[rowId][columns[columnId]</code>등으로 접근 할 수 있어야 한다.</li>
  <li>서버에서 보내주는 데이터는 배열에 담긴 객체였다.
    <ul>
      <li>모든 배열을 순회하여 가장 넓은 너비를 가진 셀을 기준으로 너비 값을 store에 보내주어야 했다.</li>
      <li>배열을 순회하며 값이 사용자가 원하는 범위의 값이라면 색으로 체크 등이 필요한것은 rowId, columnId를 통해 cell로 전달했다.</li>
    </ul>
  </li>
</ul>

<h3 id="사용자의-스크롤-지점은-과연-어떤-부분일까">사용자의 스크롤 지점은 과연 어떤 부분일까?</h3>

<ul>
  <li>앞서 언급한 레코드의 배열을 순회하며 전체 container의 너비와 높이를 알 수 있었다.</li>
  <li>컨테이너를 렌더링하고 그안에 클라이언트에 랜더링된 만큼에 테이블을 렌더링한다.
    <ul>
      <li>보여지는 부분만 렌더링 하기 위해서 스크크롤의 크기는 계산한 너비와 높이를 통해 미리 빈 element를 넣어줘서 해결한다.</li>
    </ul>
  </li>
  <li>해당 테이블이 아닌 컨테이너를 스크롤 했을때 기존에 렌더링된 테이블의 row, column은 지우고 새로운 위치의 보여줘야할 위치의 row와 column을 렌더링 해야했다.</li>
</ul>

<h3 id="보여지는-부분만-렌더링-하기-위해서">보여지는 부분만 렌더링 하기 위해서</h3>

<p>앞서 2번째 언급한 순회한 배열의 width와 height값을 통해 각 셀의 id를 부여했었다. 그리고 해당 id와 height값을 통해 높이에 대한 row계산을 하기위해 배열에 담아 관리했다.</p>

<p>이 배열에는 0~30 → 0(row) 등과 같은 데이터가 담겨져있었는데. 스크롤한 위치에 대해 첫번째 지점과 끝 지점을 찾기위해서 이진 탐색을 통해 검색하여 ‘범위’만 찾았다.</p>

<h3 id="가상그리드를-wrapping하는-angular-component를-개발">가상그리드를 wrapping하는 angular component를 개발</h3>

<ul>
  <li>angular 컴포넌트는 그리드를 그리기 위한 프로퍼티를 받는 component로 개발한다.</li>
  <li><code>element</code>를 <code>target</code> 으로 virtual-grid.ts에 전달한다. 전체적인 꼴은 아래와 같다.
    <pre><code class="language-jsx">this.grid = new Grid({
			selector: this.container.nativeElement,
			data: this.data,
// ...생략
</code></pre>
  </li>
</ul>

<h2 id="개발이-끝나고-난뒤">개발이 끝나고 난뒤</h2>

<ul>
  <li>서버에서 보내준 배열을 순회할때 너무 많은 records → 1만개 이상의 데이터일때 느려짐 worker를 사용한 계산을 고려했어야 했으나 canvas api 지원 미지수</li>
  <li>잦은 설계 변경으로 인한 리스크 난잡한 부분들이 추가되어서 리펙토링 할 시간이 없었다는게 아쉽게 느껴짐
    <ul>
      <li>셀에 어떤 기능이 필요해요 너비가 어떻게 필요해요 등등.</li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="개발" /><category term="grid" /><category term="typescript" /><summary type="html"><![CDATA[데이터 그리드]]></summary></entry><entry><title type="html">어떻게 프리서버를 만드는것을 배웠는지</title><link href="http://localhost:4000/lie/how-to-learn-open-free-server" rel="alternate" type="text/html" title="어떻게 프리서버를 만드는것을 배웠는지" /><published>2020-09-03T00:00:00+09:00</published><updated>2020-09-03T00:00:00+09:00</updated><id>http://localhost:4000/lie/how-to-learn-open-free-server</id><content type="html" xml:base="http://localhost:4000/lie/how-to-learn-open-free-server"><![CDATA[<p>프리서버 운영은 엄연한 불법 행위 입니다.</p>

<blockquote>
  <p>저작권법 제101조의4(프로그램코드역분석) ① 정당한 권한에 의하여 프로그램을 이용하는 자 또는 그의 허락을 받은 자는 호환에 필요한 정보를 쉽게 얻을 수 없고 그 획득이 불가피한 경우에는 해당 프로그램의 호환에 필요한 부분에 한하여 프로그램의 저작재산권자의 허락을 받지 아니하고 프로그램코드역분석을 할 수 있다.</p>
</blockquote>

<p>라고 <a href="https://namu.wiki/w/%ED%94%84%EB%A6%AC%EC%84%9C%EB%B2%84">나무위키</a>에서 설명하고 있습니다.</p>

<h2 id="프리서버라는-말을-접하게된-계기">프리서버라는 말을 접하게된 계기</h2>

<p>초등학교 시절 거상에 흠뻑빠져 있었다. 사냥에는 흥미가 없고 하루종일 짐꾼과 돌아다니면서 벼를 팔아 시세 차익을 내거나 한양에서 장사를 하거나 하는 행위를 주로 했다.</p>

<p>장사를 계속 하다보니까 자연스레 친구가 많이 생겼는데 어느날 한 사람이 나에게 ‘프리서버’라는걸 해본적이 있냐고 물었다. 나는 당시 프리서버라는 것에 대해서 아니 프리라는 단어 자체를 영어로 쓰지 못할정도로 어린 나이 이기 때문에 그의 이야기에 흠뻑 빠졌다.</p>

<ol>
  <li>레벨업은 내가 원하는대로 마음대로</li>
  <li>내가 가지고 싶은 장비도 마음대로</li>
  <li>그냥 게임 자체를 내 마음대로</li>
</ol>

<h2 id="초등학교-3학년-폭풍-검색-시작">초등학교 3학년 폭풍 검색 시작</h2>

<p>정확히 어떤 엔진을 사용해서 검색한지는 잘 기억이 안나지만 몇개 추려 보자면</p>

<ul>
  <li>인포마스터? (이제는 존재하지도 않는 검색 사이트)</li>
  <li>네이버 (전혀 나오지 않음)</li>
  <li>다음</li>
  <li>파란</li>
</ul>

<p>등을 사용해 검색을 몇달간 계속 했다.</p>

<p>그러나 초등학교 3학년의 통찰력과 이해로 무엇을 할 수 있으리.. 나는 당연히 프리서버를 구현하지 못했다.</p>

<h2 id="그렇게-2년뒤-피씨방에서-라그나로크-프리서버를-하는-형들을-발견">그렇게 2년뒤 피씨방에서 라그나로크 프리서버를 하는 형들을 발견</h2>

<p>아직도 기억이 난다 그 형들의 레벨업소리가 타탁! 한 마리를 잡으니 레벨이 바로 40이 되는걸 보고 말았다. 나는 불현듯 이게 프리서버라는 거구나라는 생각을 했고 뒤에서 하염없이 지켜봤다.</p>

<blockquote>
  <p>야 저리가</p>
</blockquote>

<p>나보고 거의 꺼지라는 수준의 말로 저리가라고 했지만 저 멀리서 계속 지켜봤다.</p>

<p>그리고 그현들이 오는 시간에 맞춰서 피씨방에 출근했다..</p>

<p>그리고 며칠 음료수를 형들의 책상에 두고 뒤에서 지켜보았다.</p>

<p>그렇게 한 일주일이 지나고 나도 드디어 형들의 프리서버에 들어갈 수 있는 자격이 생겼다.</p>

<p>그들은 프리서버를 운영하고 있었고 가끔 피씨방에 와서 둘이서 이것저것 게임을 고치면서 노는 학생이었다.</p>

<h2 id="어떻게-구현하는지-배워야-했다">어떻게 구현하는지 배워야 했다</h2>

<p>나에게는 7살 많은 형이 있었는데 내가 피씨방에서 보고 온것을 형은 믿지 못했다. 아니 게임을 참가 했다고 해도 형은 무슨 개소리냐며 비아냥대기 바뻤고 급기야 아버지에게 피씨방에 가지 못하게 하라고 얘기하기 시작했다.</p>

<p>오기로 이것을 배워 형하고 피씨방에 갔을대 내가 구현한것을(? 내가 구현한것은 없는데..) 보여줘야만 했다.</p>

<p>그로부터 피씨방에 조금 더 일찍 가기 시작했다.</p>

<p>옆에서 형들이 하는것을 보고 따라하고 그렇게 읿주일 나도 통파일(구현이 전부 담겨있는 팩? 같은 것)을 어떻게 구하는지와 어떻게 서버를 여는지를 배우게 되었다.</p>

<p>내 기억이 맞다면.</p>

<ol>
  <li>mysql을 통해 db서버를 연다</li>
  <li>내 서버 주소를 어떤 메모장에 옮겨 적는다.</li>
  <li>통파일 압축해제</li>
  <li>통파일에서 나온 .bat 실행 또는 cmd에서 무슨 명령어를 입력</li>
</ol>

<p>이렇게 하면 내 서버가 열리고 실행은 또 그냥 안되고 통파일에서 나온 압축 해제된 클라이언트 폴더에 가서 세팅을 바꿔줘야 한다.</p>

<p>아무튼 이렇게 해서 라그나로크 프리서버를 여는 방법을 배웠고 이후에 리니지, 바람의 나라 등을 중학교때 까지 한번 한번씩 열었었다.</p>

<p>그런데 내가 성인이 되서도 mysql을 만질줄이야!</p>]]></content><author><name></name></author><category term="개발" /><category term="자랑 아님" /><summary type="html"><![CDATA[프리서버 운영은 엄연한 불법 행위 입니다.]]></summary></entry><entry><title type="html">타입스크립트 코리아 강좌 정리</title><link href="http://localhost:4000/study/hello-typescript" rel="alternate" type="text/html" title="타입스크립트 코리아 강좌 정리" /><published>2018-10-30T00:00:00+09:00</published><updated>2018-10-30T00:00:00+09:00</updated><id>http://localhost:4000/study/hello-typescript</id><content type="html" xml:base="http://localhost:4000/study/hello-typescript"><![CDATA[<h1 id="1-typescirpt-에-관하여">1. Typescirpt 에 관하여</h1>

<blockquote>
  <p>tpyscript 는 자바스크립트를 포함한 프로그래밍 언어</p>
</blockquote>

<ul>
  <li>타입스크립트는 ‘Compiled Language’이다</li>
  <li>자바스크립트는 ‘Interpreted Language’이다</li>
</ul>

<blockquote>
  <p>그러나 엄밀히 따지자면 컴파일 언어라고 보기는 힘들고 메타 프로그래밍이라고도 하며, 트랜스파일(바밸 등) 언어라고도 보기도한다.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Compiled</th>
      <th>Interpreted</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>컴파일이 필요</td>
      <td>컴파일이 필요없음</td>
    </tr>
    <tr>
      <td>컴파일러가 필요</td>
      <td>컴파일러가 필요없음</td>
    </tr>
    <tr>
      <td>컴파일하는 시점이 있음</td>
      <td>컴파일하는 시점이 없음</td>
    </tr>
    <tr>
      <td>컴파일된 결과물 실행</td>
      <td>코드 자체를 실행</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>컴파일 언어는 최적화 과정을 거침 * 특히 타입스크립트는 타입을 체크하는 과정을 거침</p>
</blockquote>

<h2 id="정적타입-언어-vs-동적-타입-언어">정적타입 언어 VS 동적 타입 언어</h2>

<h3 id="정적타입-언어">정적타입 언어</h3>

<p>미리 타입을 정의 해놓고 사용함</p>

<h3 id="동적-타입언어">동적 타입언어</h3>

<p>타입이 정의되어 있지 않고 자유럽게 변화가 가능</p>

<p>타입스크립트는 정적타입 언어의 장점을 자바스크립트에 결합한 언어이다.</p>

<h2 id="traditional-compiled-language">Traditional Compiled Language</h2>

<ul>
  <li>컴파일 언어라고 한다</li>
  <li>C, C++, go 등</li>
  <li>일반적으로 실행시 기계어로 바꾸는 방식(인터프리터 언어)보다 빠르다.</li>
</ul>

<p>TS =&gt; JS</p>

<p>이 강좌에서 배우는 것은 컴파일은 어떤 역할을 하는지 어떤 도구들이 있고 올바르게 사용하는 방법과, 타입스크립트 자체를 이해</p>

<h1 id="2-개발-환경-구축">2. 개발 환경 구축</h1>

<h2 id="nodejs-설치">Node.js 설치</h2>

<p>강좌 외적으로 저는 Node.js 의 버전을 자유롭게 바꾸다보니 NVM 사용을 권장합니다. 예) Lambda 에서 지원하는 버전과 React 에서 지원하는 버전이 전혀 다르면서 생기는 문제 등등</p>

<p>curl 을 이용해 설치</p>

<pre><code>curl -o https://raw.githubusercontent.com/creationix/nvm/v0.26.1/install.sh | bash
</code></pre>

<h2 id="browser-설치">Browser 설치</h2>

<p>Chrome, firefox 와 같이 검사가 있는 브라우저를 추천 함</p>

<h2 id="tpyscript-compiler-설치">Tpyscript compiler 설치</h2>

<pre><code>npm i typescript -g // 전역으로 설치됩니다
</code></pre>

<h2 id="ide-설치">IDE 설치</h2>

<p><a href="https://visualstudio.microsoft.com/ko/?rr=https%3A%2F%2Fwww.google.co.kr%2F">vscode(무료)</a>, intelliJ(유료)</p>

<ul>
  <li>visual studio code 는 Typscript 로 만들어졌다.</li>
  <li>타입스크립트 지원이 강력하다</li>
</ul>

<h2 id="tsc-init">tsc init</h2>

<p>tsc 설정 파일을 init 함
target, module, strict 정도가 기본 설정으로 되어있음.</p>

<h2 id="ts-lint">ts lint</h2>

<pre><code>npm i tslint -D
</code></pre>

<p>tslint –init</p>

<h1 id="3-compiler-options">3. Compiler Options</h1>

<h2 id="tsconfig">tsconfig</h2>

<p><a href="http://json.schemastore.org/tsconfig">ts config 가이드</a></p>

<h2 id="최상위-프로퍼티">최상위 프로퍼티</h2>

<ol>
  <li>CompileOnSave: 파일 저장시 자동 컴파일, Visual studio에서 사용 가능</li>
  <li>extends: v2.1 new spec</li>
  <li>compileOptions
    <ul>
      <li>다양한 옵션이 제공됨</li>
      <li>typeRoots: 배열 안에 들어있는 경로들 아래에 모듈만 가져옴</li>
      <li>types: 배열 안에 모듈, ./node_modules/@types/ 안의 모듈 이름에서 찾아옴</li>
      <li>typeRoots, types와 함께 사용하지 않음</li>
      <li>target: 컴파일 해서 어떤 자바스크립트 버전으로 downgrade 시킬거냐 기본은 es3이다</li>
      <li>lib: 기본 type definition 라이브러리를 어떤 것을 사용할 것이냐
        <ul>
          <li>lib를 지정하지 않을때</li>
          <li>target이 ‘es3’이고 디폴트로 lib.d.ts를 사용함</li>
          <li>target이 ‘es5’이면, 디폴트로 dom, es5, scripthost를 사용함</li>
        </ul>
      </li>
      <li>outDir: 소스 구조의 전부를 컴파일 하려면 사용</li>
      <li>outFile: 구조 상관없이 컴파일 하려면 사용</li>
      <li>module: 결과물이 어떤 js파일을 쓸건지 target이 es6면 es6가 기본값, es6가 아니면 ‘commonjs’가 기본값</li>
    </ul>
  </li>
  <li>files:
    <ul>
      <li>상대 혹은 절대 경로의 리스트 배열</li>
      <li>exclude 보다 우선순위 높음</li>
    </ul>
  </li>
  <li>include
    <ul>
      <li>exclude 보다 우선순위 낮음</li>
      <li>*같은걸 사용하면 .ts / .tsx 등 설정한 것만 include 함</li>
    </ul>
  </li>
  <li>exclude
    <ul>
      <li>설정 안하면 기본 4가지를 설정 (node_modules, browser_components, jspm_packages, outDIr)를 기본적으로 제외</li>
      <li>outDir은 항상 제외</li>
    </ul>
  </li>
</ol>

<h1 id="4-typescript-basic-type">4. typescript basic type</h1>

<ul>
  <li>Typescript에서 프로그램 작성을 위해 기본 제공하는 데이터 타입</li>
  <li>Javscript 기보 자료형을 포함
    <ul>
      <li>ECMAScript 표준에 따른 기본 자료형은 6가지</li>
      <li>Boolean</li>
      <li>String</li>
      <li>Null</li>
      <li>Undefined</li>
      <li>Symbol</li>
      <li>Array: Object형</li>
    </ul>
  </li>
  <li>프로그래밍을 도울 몇가리 타입이 더 제공됨
    <ul>
      <li>Any</li>
      <li>Void</li>
      <li>Never</li>
      <li>Enum</li>
      <li>Tuple: Object</li>
    </ul>
  </li>
</ul>

<h2 id="literal">literal?</h2>

<p>값자체가 변하지 않는 값을 의미함
상수와 다른 것은 상수는 가리키는 포인터가 고정이라는 것이고, 리터럴은 그 자체가 값이자 리터럴</p>

<h2 id="권장-소문자를-사용해라">권장 소문자를 사용해라</h2>

<p>new Number(5) -&gt; number(5);</p>

<p>new Boolean(false) -&gt; boolrean(false);</p>

<h2 id="any">Any</h2>

<ul>
  <li>어떤 타입이든 상관없음</li>
  <li>그러나 권장하지 않음 (이걸 쓸꺼면 그냥 es6바밸 문법을 사용해라)</li>
</ul>

<h2 id="tuple">Tuple</h2>

<ul>
  <li>배열인데 한가지 타입이 아닐 경우</li>
  <li>객체</li>
  <li>사용할때 주의가 필요함</li>
</ul>

<h1 id="5-var-let-const">5. var, let, const</h1>

<ul>
  <li>var
    <ul>
      <li>es5</li>
      <li>함수 스코프</li>
      <li>호이스팅이 가능</li>
      <li>재선언 가능</li>
    </ul>
  </li>
  <li>let, const
    <ul>
      <li>es6</li>
      <li>블록 스코프</li>
      <li>호이스팅 불가능</li>
      <li>재선언 불가</li>
    </ul>
  </li>
  <li>var 말고 let, const를 사용하자</li>
</ul>

<h2 id="let-const-차이점">let, const 차이점</h2>

<pre><code class="language-javascript">let a: string = "에이";
let a = "에이"; //자동으로 String으로 타입을 맞춰줌

const b: string = "비";
const b = "비"; //별도의 타입을 만들어 주지 않음
</code></pre>

<h1 id="6-type-assersions">6. Type assersions</h1>

<ul>
  <li>형변환과는 다름
    <ul>
      <li>형변형은 실제 데이터 구조를 바꿔줌</li>
    </ul>
  </li>
  <li>‘타입이 이것이다’라고 컴파일러에게 알려주는 것을 의미함
    <ul>
      <li>그래서 작성자가 100% 신뢰하는 것이 중요하다.</li>
    </ul>
  </li>
  <li>문법적으로는 두가지 방법이 있다
    <ul>
      <li>변수 as 강제할 타입</li>
      <li>
        <강제할 타입="">변수

</강제할>
      </li>
    </ul>
  </li>
</ul>
<pre><code class="language-javascript">let a: any = "this is a string";
let b: number = (someValue as a).length;
</code></pre>

<h2 id="타입-별칭">타입 별칭</h2>

<ul>
  <li>인터페이스와 유사해 보임</li>
  <li>Primitive, Union Type, Tuple</li>
  <li>기타 직접 작성해야하는 타입을 다른 이름에 저장할 수 있다.</li>
  <li>만들어진 타입의 refer로 사용하는 것이지 타입을 만드는것은 아니다.</li>
</ul>

<h3 id="union">Union</h3>

<pre><code class="language-javascript">let a: any;
let b: string | number;

b = "스트링";
b = 0;

//만약 사례가 복잡하다면?

function test(arg: string | number): string | number {
  return arg;
}
//위와 같이 작성할때마다 해주는게 힘들다보니 사용함
type StringOrNumber = string | number; //이게 union타입

function test(arg: StringOrNumber): StringOrNumber {
  return arg;
}
</code></pre>

<h3 id="interface">interface</h3>

<pre><code class="language-javascript">//interface가 없다면
const person: { name: string, age: number } = {
  name: "MrMoon",
  age: 12,
};

//interface를 사용한다면
interface Person {
  name: string;
  age: number;
}
const person: Person = {
  name: "mrMoon",
  age: 12,
};

// 주요 사용처
function hello(p: Person): void {
  console.log(`안녕하세요 ${p.name} 입니다`);
}
</code></pre>

<h3 id="interface-optional">interface optional</h3>

<pre><code class="language-javascript">interface Person {
  name: string;
  age?: number; //age를 강제하지 않음
}
</code></pre>

<h3 id="indexable-type">indexable type</h3>

<pre><code class="language-javascript">interface Person {
    name: string;
    [index: string]: string;
}
const person : Person = {
    name: "mark";
}
person.anybody = "Anna";

//여기서 접근하는 index를 어레이로 선언했기 때문에 가능 함
interface Person2 {
    [index: number]: string;
}

const p2: Person2 = {};
p2[0] = "hi";
p2[100] = "hello";
</code></pre>

<p>위와 같이 array에 string이나 number로 interface를 만들어줄 순 있지만 array는 아님</p>

<h2 id="interface-in-funciton">interface in funciton</h2>

<pre><code class="language-javascript">interface Person {
  name: string;
  hello(): string;
}

const person: Person = {
  name: "mark",
  hello(): string {
    return "hello world";
  },
};
</code></pre>

<h2 id="class-implements-interface">class implements interface</h2>

<pre><code class="language-javascript">interface IPerson {
  name: string;
  hello(): void;
}

class Person implements IPerson {
  name: string = null;

  constructor(name: string) {
    this.name = name;
  }
  hi(): void {
    console.log("This is hi");
  }
  hello(): void {
    console.log(`hello i am ${name}`);
  }
}

const person: IPerson = new Person("moon");
const person: Person = new Person("moon");
//두가지 모두 사용 가능하다
</code></pre>

<blockquote>
  <p>IPerson의 타입을 가지고 있는 person은 interface에서 정의하지 않은 hi 함수에 접근할 수 없다.</p>
</blockquote>

<h2 id="string-or-number">string OR number</h2>

<pre><code class="language-javascript">interface StringArray {
  [index: number]: string;
}

const sa: StringArray = {};
sa[100] = "백";
</code></pre>

<h1 id="7-클래스">7. 클래스</h1>

<h2 id="class">class</h2>

<pre><code class="language-javascript">class Person {
  name: string;
  age: number;
  // 모든 프로퍼티는 public
  constructor(name: string) {
    this.name = name;
  }

  // 할당하지 않는 변수는 undefined가 되어서 나오지 않음
  // 그래서 = null이라고 해주는게 일단 좋음 (기본적인 프로그래밍 방식)
}

const person = new Person("Mark");
</code></pre>

<ol>
  <li>생성사 함수가 없으면 디폴트 생성자가 불린다.</li>
  <li>클래스의 프로퍼티 혹은 멤버 변수가 정의되어 있지만, 값을 대입하지 않으면 undefined이다.</li>
  <li>접근 제어자는 public이 디폴트 이다.</li>
</ol>

<h2 id="접근-제어자---private">접근 제어자 - private</h2>

<pre><code class="language-javascript">class Person {
    private _name: string = 'Mark';
    private _age: number;
}

const person = new Person('Mark');
</code></pre>

<ol>
  <li>디폴트 값은 public 이고 private 로 선언한 프로퍼티 접근 불가능 (c#과 흡사)</li>
</ol>

<h2 id="protected">protected</h2>

<p>private는 부모 클래스건 어디서건 절대로 접근이 안되는 반면에 protected는 부모에서는 접근이 가능함</p>

<pre><code class="language-javascript">class Person {
    protected _name: string = 'amark';
    private _age: number = null;
}

class Child extends Person {

    constructor() {
        super(); // constructor에서 무언가 작업을 하기 위해서는 super를 해줘야함 (상속 받았을 때)

        this._name += '아들';

    }
    getName() {
        return this._name
    }
    getAge() {
        return this._age //접근이 안됨
    }
}

const person: Child = new Child();

</code></pre>

<h2 id="클래스와-메서드">클래스와 메서드</h2>

<pre><code class="language-javascript">class Person {
    // protected _name: string = 'amark';
    // private _age: number = null;

    // 굳이 변수 선언없이 이렇게 해도 가능
    constructor(protected name: string, protected age: number){

    }

    hello(): void {
        console.log(this.name);
    }

    //arrow function도 가능
    printHello = (): void =&gt; {
        console.log('hello world');
    }
}

const person: Person = new Person('Moon', 35);

class Child extends Person {

    constructor() {
        super('Mark Jr', 5);
    }
}

const child: Child = new Child('Mark', 35);
child.hello();
// console : Mark Jr
</code></pre>

<ul>
  <li>클래스를 상속받아서 사용하려면 꼭 constructor 에서 super()를 해줘야함</li>
</ul>

<h2 id="클래스의-getter-setter">클래스의 getter, setter</h2>

<pre><code class="language-javascript">
interface IPerson {
    getName();
}

//인터페이스에서 이렇게 사용할 수도 있음

class Person implements IPerson{
    private _name: string;
    private _age: number;

    constructor(name: string, age: number) {
        this._name = name;
        this._age = age;
    }

    get name() {
        return this._name;
    }

    set name(name: string) {
        this._name = name;
    }

    // get set을 안쓰고 이방법도 사용 가능

    getName(): string {
        return this._name;
    }
}

const person: IPseron = new Person('moon', 26);
console.log(person.name); // moon
person.name = 'moon jong min';
console.log(person.name); // moon jong min

const person: IPerson = new Person('Mark', 35);
person.getName();

// interface를 활용 하면 이런식으로도 사용 가능함
</code></pre>

<h2 id="class의-static-프로퍼티-메서드">class의 static 프로퍼티, 메서드</h2>

<pre><code class="language-javascript">class Person {
    public static HEIGHT: number;

    public static Talk(): void {
        console.log('안녕하세요');
    }
}

const person: Person = new Person();
person.HEIGHT // 접근안됨

Person.HEIGHT // 접근됨 (클래스 자체에 프로퍼티가 동적으로 생성됨)
Person.Talk(); // 동일함
</code></pre>

<ul>
  <li>동적으로 생성된다는 얘기에 좀 집중을 해봐야 할것 같은데 변화도 가능하다는 점이다.</li>
  <li>리엑트할 때도 사용되는 default props 같은 경우에 사용됨</li>
  <li>역시 static을 너무 사용하면 좋지 않음</li>
  <li>public static은 의미가 있음</li>
  <li>private static의 의미는 고민이 필요함</li>
</ul>

<h2 id="anstract-class---미완된-클래스">Anstract Class - 미완된 클래스</h2>

<pre><code class="language-javascript">abstract class APerson {
    protected _name: string = 'Mark';
    abstract setName(name: string): void;
    // 이렇게 미완성으로 만들어 놓고 상속받거나 할때 사용 가능함
}
</code></pre>

<h2 id="class와-private-constructor">class와 private constructor</h2>

<pre><code class="language-javascript">// 싱글톤 예제
class Perference {
    private static Instance: Perference = null;
    public static getInstance(): Perference {
        if(Perference.Instance === null){
            Preference.Instance = new Preference();
        }

        return Preference.Instance;
    }
    private constructor() {

    }

    hello() {

    }
}

const p = Perference.getInstance();
p.hello();
</code></pre>

<h2 id="class와-readonly">class와 readonly</h2>

<pre><code class="language-javascript">class Person {
    private readonly _name: string = null;
}
</code></pre>

<ul>
  <li>readonly는 get, set중에 get만 있는것과 흡사하다.</li>
</ul>

<h1 id="8-generic">8. generic</h1>

<ul>
  <li>any -&gt; generic</li>
  <li>제네릭을 쓰는 가장 큰 이유는 템플릿 라이브러리 (cpp)처럼 타입을 변수로 주고 싶을때 사용함</li>
</ul>

<pre><code class="language-javascript">function hello&lt;T&gt;(message: T): T {
  return message;
}

hello &lt; string &gt; "hello moon";
hello &lt; string &gt; "hello moon".length; //문자열의 내장 함수도 사용가능
hello &lt; number &gt; 35;

const a: string[] = [];
const b: Array&lt;string&gt; = [];
</code></pre>

<ul>
  <li>메시지가 number, string에 상관없이 가능함</li>
  <li>장점은 any로 사용하면 헬퍼같은게 제대로 작동이 되지 않는데 제네릭은 정상 작동함</li>
</ul>

<h2 id="generic-인자">generic 인자</h2>

<pre><code class="language-javascript">function hello&lt;T&gt;(message: T[]): T {
  return message[0];
}
</code></pre>

<ul>
  <li>T의 array 형태로도 사용할 수 있다.</li>
</ul>

<h2 id="generic-class">generic class</h2>

<pre><code class="language-javascript">class Person&lt;T&gt; {
    private _name: T;

    constructor(name: T) {
        this._name = name;
    }
}

const mark = new Person('Mark');
new Person&lt;number&gt;('Mark'); //error!
</code></pre>

<ul>
  <li>name의 타입이 설정하는 대로 되어줌</li>
</ul>

<h2 id="generic-with-extends">generic with extends</h2>

<pre><code class="language-javascript">class Person&lt;T extends string | number&gt; {
    private _name: T;

    constructor(name: T) {
        this._name = name;
    }
}

const mark = new Person('mark');
</code></pre>

<h2 id="generic-with-multiple-type">generic with multiple type</h2>

<pre><code class="language-javascript">class Person&lt;T, K&gt; {
    private _name: T;
    private _age: K;

    constructor(name: T, age: K) {
        this._name = name;
        this._age = age;
    }
}

const mark = new Person('mark', 35);
</code></pre>

<h2 id="type-lookup-system">type lookup system</h2>

<ul>
  <li>2.1 버전에 나옴</li>
</ul>

<pre><code class="language-javascript">interface Person {
    name: string;
    age: number;
}

// type Test = keyof Person;

// function getProperty(obj, key) {
//     return obj[key]; //가끔이 key가 없을땐 undefined 에러를 뿜는데 (나도 겪음) 이걸 해결하는데 lookup system
// }

function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K]{
    return obj[key];
}

function setProperty&lt;T, K extends keyof T&gt;(obj: T, key: K, value: T[K]): T[K]{
    obj[key] = value
}

const person: Person = {
    name: 'Mark',
    age: 35
}

getProperty(person, 'name');
setProperty(person, 'name', 'anda');
</code></pre>

<ul>
  <li>상당히 자주 쓰일것 같음</li>
  <li>// type Test = keyof Person; 이 부분이 좀 중요한것 같은데 keyof Person을 해줬기 때문에 Test는 리터럴로 name, age 프로퍼티를 갖게 되는것</li>
</ul>

<h1 id="9-iterator">9. iterator</h1>

<h2 id="forof">for…of</h2>

<ul>
  <li>es3
    <ul>
      <li>for (var i=…)</li>
    </ul>
  </li>
  <li>es5
    <ul>
      <li>array.forEach
        <ul>
          <li>break 를 할 수 없었따.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>es6
    <ul>
      <li>for of
        <ul>
          <li>원칙적으로는 배열에서만 사용 가능</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="forin">for…in</h2>

<ul>
  <li>배열을 순회할 때는 사용하지 말것
    <ul>
      <li>index가 number가 아니라 string으로 나온다.</li>
      <li>배열의 프로퍼티를 순회할 수도 있따.</li>
      <li>prototype 체인의 프로퍼티를 순회할 수도 있다.</li>
      <li>루프가 무작위로 수회할 수도 있다.</li>
      <li>for of를 쓸 것</li>
    </ul>
  </li>
  <li>객체를 순회할 때
    <ul>
      <li>for(const prop of Object.keys(obj))도 사용할 수 있음</li>
    </ul>
  </li>
</ul>

<h2 id="target-es3-foreach">target es3 forEach</h2>

<ul>
  <li>트렌스파일시에 es3인데도 lib에서 잘못 판단되어서 적용이 안되고 es5 기준으로 생성됨</li>
</ul>

<h2 id="sysmboliterator">Sysmbol.iterator</h2>

<ul>
  <li>프로퍼티이며, 함수가 구현되어있으면, iterable 이라고 한다.</li>
  <li>Array, Map, Set, String, Int32Array, Unit32Array, etc, 에는 내장된 구현체가 있으므로 이터러블 하다.</li>
  <li>그냥 객체는 이터러블하지 않다.</li>
  <li>이터레이터를 통해 이터러블한 객체의 Symbol.iterator함수를 호출한다.</li>
  <li>traget: es3 or es5
    <ul>
      <li>Array 에만 for..of사용 가능</li>
      <li>일반 객체에 사용하면 오류</li>
    </ul>
  </li>
  <li>target: es6
    <ul>
      <li>Symbol.iterator를 구현하면 사용 가능</li>
    </ul>
  </li>
</ul>

<h2 id="custom-iterable">custom iterable</h2>

<pre><code class="language-javascript">class CustomIterable implements Iterable&lt;string&gt; {
    private _array: Array&lt;string&gt; = ['first', 'second'];

    [Symbol.iterator]() {
        var nextIndex = 0;

        return {
            next: () =&gt; {
                return {
                    value: this._array[nextIndex++],
                    done: nextIndex &gt; this._array.length
                }
            }
        }
    }
}

const cIterable = new CustomIterable();

for (const item of cIterable) {
    console.log(item);
}
</code></pre>

<ul>
  <li>배열의 이터레이터를 돌면 예 for of 객체의 for을 돌리면 커스텀한 for of 로 돌리면 class 내부에 있는 배열도 사용 가능하기에 사용함.</li>
  <li>사실 무슨 말 인지..</li>
</ul>

<h1 id="10-decorator">10. Decorator</h1>

<ul>
  <li>Class</li>
  <li>Method</li>
  <li>Property</li>
  <li>
    <p>Parameter</p>
  </li>
  <li>모든 decorator 는 function이다</li>
</ul>

<h2 id="class-decorator">class decorator</h2>

<pre><code class="language-javascript">function hello(constructorFn: Function) {
  console.log(constructorFn);
}

function helloFactory(show: boolean) {
  if (show) return hello;
  else return null;
}

@helloFactory(false)
class Person {}
</code></pre>

<h2 id="class-decorator-expert">class decorator expert</h2>

<pre><code class="language-javascript">function hello(constructorFn: Function) {
    constructorFn.prototype.hello = function() :void {
        console.log('hello');
    }
}

@hello
class Person {

}

const p = new Person();
(&lt;any&gt;p).hello(); // 이런식으로 밖에 사용해야함

</code></pre>

<h2 id="method-decorator">method decorator</h2>

<pre><code class="language-javascript">function editable(canBeEditable: boolean) {
  return function (
    target: any,
    propName: string,
    description: PropertyDescriptor
  ) {
    console.log(target);
    console.log(propName);
    console.log(description);

    description.writable = canBeEditable;
  };
}

class Person {
  constructor() {
    console.log("new Person ()");
  }

  @editable(false)
  hello(): void {
    console.log("hello");
  }
}

const p = new Person();
p.hello();

p.hello = function () {
  console.log("world");
};
p.hello();
</code></pre>

<h2 id="property-decorator">property decorator</h2>

<pre><code class="language-javascript">function writetable(canBeWriteable: boolean) {
  return function (target: any, propName: string): any {
    console.log(target);
    console.log(propName);

    return {
      writetable: canBeWriteable,
    };
  };
}

class Person {
  @writetable(true)
  name: string = "Mark";

  constructor() {
    console.log("new Person ()");
  }

  hello(): void {
    console.log("hello");
  }
}

const p = new Person();
console.log(p.name);
</code></pre>

<h2 id="parameter-decorator">parameter decorator</h2>

<pre><code class="language-javascript">function printInfo(target: any, methodName: string, paramIndex: number) {
    console.log(target);
    console.log(methodName);
    console.log(paramIndex);

}

class Person {
    private _name: string;
    private _age: number;

    constructor(name: string, @printInfo age: number) {
        this._name = name;
        this._age = age;
    }

    hello(@printInfo message: string): void {
        console.log(message)
    }

}


// const p = new Person('Mark', 35);
</code></pre>

<ul>
  <li>개인적으로 decorator는 예를들면 프레임워크를 만들때나 어떠한 모듈을 만들때 변수 검증 등을 하는데 사용하면 요긴하게 쓰일것 같다는 생각이 들었다.</li>
</ul>

<h1 id="11-type-inference">11. Type Inference</h1>

<h2 id="타입-추론">타입 추론</h2>

<ul>
  <li>기본적으로 타입을 명시적으로 스지 않을 때 추론하는 방법에 대한 규칙
    <ul>
      <li>명시적으로 쓰는 것은 타입 추론이 아니라 코드를 읽기 좋게 하는 지름길</li>
    </ul>
  </li>
  <li>let은 기본적으로 우리가아는 기본 자료형으로 추론</li>
  <li>const는 리터럴 타입으로 추론
    <ul>
      <li>오브젝트 타입을 쓰지 않으면, 프로퍼티는 let 처럼 추론
        <ul>
          <li>const person = {name: ‘Mark’, age: 35}</li>
          <li>person =&gt; {name:string; age: number}</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>대부분 추론은 쉽다.
    <ul>
      <li>단순 변수</li>
      <li>structing, destruction</li>
    </ul>
  </li>
  <li>array, 함수의 리턴에서는 워하는데로 얻기가 힘들다.</li>
</ul>

<h2 id="배열-타입-추론">배열 타입 추론</h2>

<pre><code class="language-javascript">const aaray1 = []; // any type으로 추론함
const array2 = ["a", "b"]; // array string
const array3 = ["a", 1, "cone"]; // union type으로 추론함

class Animal {
  name: string;
}

class Dog extends Aniaml {
  dog: string;
}

class Cat extends Animal {
  cat: string;
}

const array4 = [new Dog(), new Cat()]; // union dog | cat
</code></pre>

<h2 id="리턴-타입-추론">리턴 타입 추론</h2>

<pre><code class="language-javascript">function hello(message: string | number) {
  // 리터럴 타입의 world이거나 0을 추론
  if (message === "world") return "world";
  else return 0;
}
</code></pre>

<h2 id="유니온-타입과-가드">유니온 타입과 가드</h2>

<pre><code class="language-javascript">interface Person {
    name: string;
    age: number;
}

interface Car {
    brand: string;
    wheel: number;
}

function isPerson(arg: any): arg is Person {
    return arg.name !== undefined;
} // 이 부분이 타입가드

function hello(obj: Person | Car) {
    if (isPerson(obj)) {
        obj.age;
  }
}
</code></pre>

<h2 id="마치며">마치며</h2>

<p>약 11개의 챕터이자 강좌는 14개인 타입스크립트 코리아에서 만든 이 강좌는 <a href="https://www.youtube.com/watch?v=PFBRhxjIBUM&amp;list=PLV6pYUAZ-ZoHx0OjUduzaFSZ4_cUqXLm0">유튜브</a>에서 확인하실 수 있습니다.</p>

<p>타입스크립트를 막연하게 어렵다고만 생각했었는데 오히려 프로그램을 작성하는데 있어서 더욱더 안정성이 있다는것은 이 강좌를 통해서 확실히 알게되었다.</p>

<p>실제로 직접 가서 참여한 세미나보다도 상당히 훌륭했고 예제들 역시 상당히 훌륭했다.</p>]]></content><author><name></name></author><category term="개발" /><category term="Typescript" /><category term="beginer" /><summary type="html"><![CDATA[1. Typescirpt 에 관하여]]></summary></entry><entry><title type="html">남궁성 자바스크립트 기초 세미나 정리</title><link href="http://localhost:4000/study/namgungsung_beginer_javascript_semina" rel="alternate" type="text/html" title="남궁성 자바스크립트 기초 세미나 정리" /><published>2018-10-27T00:00:00+09:00</published><updated>2018-10-27T00:00:00+09:00</updated><id>http://localhost:4000/study/namgungsung_beginer_javascript_semina</id><content type="html" xml:base="http://localhost:4000/study/namgungsung_beginer_javascript_semina"><![CDATA[<h2 id="남궁성-자바스크립트에-참가하다">남궁성 자바스크립트에 참가하다.</h2>

<p>예전에 ‘난 정말 자바를 공부한적이 없다구요’라는 책을 보고 남궁성 자바라는 카페를 가입했었는데 어쩌다보니 자바는 전혀 하지 않고 Jvacsript만 주로 하게되었는데 운 좋게 남궁성님이 운영하는 세미나가 있어서 참가하게 되었다.</p>

<p>물론 처음엔 늦게 신청해서 아쉽게도 참가권에서 밀려났지만 운이 좋게도 한자리 비어서 진행하게되었다.</p>

<p>이 글은 내가 이 세미나를 들으며 정리하며 내용을 담기로 했다.</p>

<h2 id="목차">목차</h2>

<ol>
  <li>Javascript 역사</li>
  <li>개발도구의 종류와 장단점 - VS code, Webstorm, Atom 등</li>
  <li>변수의 타입과 선언</li>
  <li>입력과 출력</li>
  <li>연산자 - new, typeof, instanceof</li>
  <li>조건문과 반복문 - for each, for in</li>
  <li>배열</li>
  <li>내장객체 형변환함수, ““와 new String(““)의 차이</li>
  <li>함수
    <ul>
      <li>함수 기본</li>
      <li>매개변수</li>
      <li>변수의 스코프</li>
      <li>클로져</li>
    </ul>
  </li>
  <li>DOM과 이벤트 처리</li>
  <li>객체와 생성자
    <ul>
      <li>생성자와 this</li>
      <li>prototype</li>
      <li>constructor</li>
      <li>js에서의 다형성</li>
      <li>상속</li>
    </ul>
  </li>
</ol>

<h2 id="javascript의-역사">Javascript의 역사</h2>

<ul>
  <li>1995년에 Eredan Eich가 발명, ECMA가 1997년에 표준화 했음</li>
</ul>

<p>HTML이 원래는 하이퍼링크만 주어진 단순한 문서였는데 이를 동적으로 변화하기 위해서 Javascript로 만들어졌음</p>

<p>원래 개발당시에는 OOP를 고려하지 않았지만 현재는 상당히 많은 부분에서 사용중이고 현재는 이를 넘어서 함수형 언어가 되었음.</p>

<p>현재는 Javascirpt가 안쓰이는 곳이 없다. 보안, 출판, Indesign은 Javascript로 책을 자동화로 만들게끔 도와준다.</p>

<p>실무에선 Jquery를 많이 쓰이는데 탈피해서 자바스크립트 본연으로 돌아가서 JS를 사용하는 경우가 많아지고 있음</p>

<p>오늘 세미나에서는 JAVA와 js의 차이점에서 대해서 많이 둘거고 실습을 위주로 진행함</p>

<p>ECMA5와 ECMA6의 차이는 OOP를 추가했다는 점이며 오늘은 ECMA5위주로 진행을 함</p>

<p>Javascript에서 window 의미하는것은 브라우저를 뜻함</p>

<h2 id="개발도구의-종류와-장단점">개발도구의 종류와 장단점</h2>

<h2 id="변수의-타입과-선언">변수의 타입과 선언</h2>

<h3 id="hoisting">hoisting</h3>

<ul>
  <li>변수나 함수 선언이 스코프에서 최상단으로 옮겨가는 것</li>
</ul>

<pre><code class="language-javascript">num = 5;
var num2 = 1;
console.log(num2);
var num;
console.log(num);

//여기서 num의 선언을 최상단으로 자동으로 올려줌
</code></pre>

<p>권장하지 않는 프로그래밍임</p>

<h3 id="scope">Scope</h3>

<ul>
  <li>함수 내부가 아니면 전부 전역 (var)</li>
  <li>전역 선언에 경우 브라우저에 변수가 저장된다.</li>
  <li>지역 변수는 함수 내부에 선언된 선언이 지역변수로 저장된다.</li>
  <li>변수 선언을 함수든 어디서든 안하면 전역으로 선언됨</li>
</ul>

<pre><code class="language-javascript">function sum(a, b) {
  var result = 0;
  gResult = 0;

  for (var i = 0; i &lt; arguments.length; i++) {
    gResult += arguments[i];
    console.log(i);
  }
  //var i는 호이스팅에 의해서 최상단으로 올라가게됨
}

console.log(gResult); //undefined
sum(10, 50);
// 0
// 1
console.log(gResult); // 60;
</code></pre>

<pre><code class="language-javascript">// false인지 ture인지 확인하려면 그냥 타입에 !!해보면됨
console.log(!!undefined);
// false
</code></pre>

<h2 id="연산자">연산자</h2>

<ul>
  <li>’==’ ‘===’의 차이 ==는 값비교 ===는 타입까지 비교</li>
</ul>

<pre><code class="language-javascript">var num = new Number(0);
var num1 = 0;
console.log(num === num1);
// false
// 타입이 다르다 new Number는 객체이기 때문
</code></pre>

<ul>
  <li>결론 ==는 쓰지마라</li>
</ul>

<pre><code class="language-javascript">var num = new Number(0);
var num1 = 0;
console.log(num == num1);
// true
</code></pre>

<p>여기에서 num을 자동으로 형변환을 시키기 때문에 좋지 않다.</p>

<h2 id="조건문과-반복문">조건문과 반복문</h2>

<h2 id="배열">배열</h2>

<pre><code class="language-javascript">var arr = [1, 2, 3, 4, 5];
arr[6] = 100;

console.log(arr);
//1,2,3,4,5, ,100

for (var i in arr) console.log(arr[i]);
// empty, undefined는 건너뜀 in의 특징임
</code></pre>

<pre><code class="language-javascript">var arr = [1, 10, 20, 11, 12, 30];
arr.sort(); // 는 사전 정렬이라서 제대로 되지않음
// 그래서 이렇게함
arr.sort((a, b) =&gt; a - b);
</code></pre>

<h2 id="dom">DOM</h2>

<ul>
  <li>DOM은 기본적으로 노드로 생성된다.</li>
</ul>

<h2 id="난-정말-자바를-공부한적이-없다구요">난 정말 자바를 공부한적이 없다구요</h2>

<p>찾아보니 남궁성님이 안쓰셨다. 잘못알고 왔다. 망했다.</p>

<h2 id="후기">후기</h2>

<p>이 글을 읽은 사람이라면 누구나 왜 목차랑 인마 달라 이자식아 라는 생각을 하실 수 있다 그렇다 목차와 다르게 세미나가 진행됐다.</p>

<p>그리고 시간이 모자라서 DOM의 이벤트는 하지 않고 지나갔다.</p>

<blockquote>
  <p>괜히 갔나 후회 했다</p>
</blockquote>

<p>솔직히 말하면 시간을 버렸고 돈을 버렸다고 생각했다. 기존에 전부 알던 내용이고 복습을 할거면 MSDN을 볼것이고 그것마저도 아니라면 많은 자바스크립트 교재를 한번 훑어보는게 좋다고 생각한다.</p>

<p>물론 초보자 입장에선 이 강좌가 어떻게 다가올진 모르겠다. 좋다고 생각하는 사람도 있을것이고 그럴것 같다</p>

<p>그러나 현재 프론트엔드나 자바스크립트 개발을 보자면 es5 기준으로 프로그래밍을 하는 경우는 전혀 없다고 확신한다.</p>

<p>타입스크립트, ES6(바밸을 통한)면 모를까 상당히 안타까운 시간이었고 설명 자체도 본인이 가져오신 교재를 통해 읽는 것만 반복되는 느낌이었다.</p>

<p>자바를 알고 있는 사람을 전제하에 세미나가 진행된다고 하셨는데 어느정도 자바를 아는 사람이라면 굳이 세미나를 참가하지 않고 변수 선언 등…을 살펴보기는게 좋지 않을까?</p>

<p>완전 초보자가 듣기에는 너무 급하게 지나가서 내 옆자리 분은 실제로 제대로 이해하지 못하고 지나갔고 조금 경험이 있는 개발자는 시간이 아깝다고 느끼며 지나갔다.</p>

<p>이도저도 아닌 세미나였어서 더 이상 쓸 말이 없다.</p>

<p>책을 사시는것을 추천한다.</p>]]></content><author><name></name></author><category term="개발" /><category term="Javascript" /><category term="beginer" /><summary type="html"><![CDATA[남궁성 자바스크립트에 참가하다.]]></summary></entry><entry><title type="html">자바스크립트의 재귀함수 어떻게 이해하면 좋을까?</title><link href="http://localhost:4000/study/How-to-understand-javascript-recursion-function" rel="alternate" type="text/html" title="자바스크립트의 재귀함수 어떻게 이해하면 좋을까?" /><published>2018-08-24T00:00:00+09:00</published><updated>2018-08-24T00:00:00+09:00</updated><id>http://localhost:4000/study/How-to-understand-javascript-recursion-function</id><content type="html" xml:base="http://localhost:4000/study/How-to-understand-javascript-recursion-function"><![CDATA[<h2 id="재귀함수-recursion-function">재귀함수 (Recursion function)</h2>

<p>재귀함수는 말 그대로 함수 내에서 자기 자신을 다시 또 호출하면서 로직을 수행하는 함수를 말한다. 재귀함수를 응용하는데 있어서 많은 글들을 읽어봤지만 사실 그렇게 크게 와닿는 글은 없었던것 같다.</p>

<h2 id="예제-보기">예제 보기</h2>

<p><a href="https://msdn.microsoft.com/ko-kr/library/wwbyhkx4(v=vs.94).aspx">MSDN</a>의 예제를 살펴보자</p>

<p>팩토리얼에 재귀함수를 활용하는 예제인데</p>

<pre><code class="language-javascript">function factorial(num) {
  // If the number is less than 0, reject it.
  if (num &lt; 0) {
    return -1;
  }
  // If the number is 0, its factorial is 1.
  else if (num == 0) {
    return 1;
  }
  var tmp = num;
  while (num-- &gt; 2) {
    tmp *= num;
  }
  return tmp;
}

var result = factorial(8);
document.write(result);

// Output: 40320
</code></pre>

<p>위와같은 팩토리얼 함수를 재귀함수로 아래와같이 만들수 있다는 내용이다.</p>

<pre><code class="language-javascript">function factorial(num) {
  // If the number is less than 0, reject it.
  if (num &lt; 0) {
    return -1;
  }
  // If the number is 0, its factorial is 1.
  else if (num == 0) {
    return 1;
  }
  // Otherwise, call this recursive procedure again.
  else {
    return num * factorial(num - 1);
  }
}

var result = factorial(8);
document.write(result);

// Output: 40320
</code></pre>

<h2 id="간단한-예제-그러나-사용처는">간단한 예제 그러나 사용처는?</h2>

<p>본인도 그랬다 물론 이해는 되지만 ‘재귀함수’를 사용하면서 얻는 이점이 무엇이 있는지 사실 이해가 잘 가지 않았다.</p>

<p>왜냐면 후자의 예제 역시 동작이 되며 모두다 같은 결과 값을 가져다 주기 때문이다.</p>

<p>그러던 도중 타인에게 문제를 받아 해결하는 과정에서 재귀함수를 사용해 꽤 간단하게 문제를 풀어냈기에 이 예제를 본다면 다른 사람도 어느정도 도움이 될것 같아서 작성하게 되었다.</p>

<h2 id="다차원-배열을-1차원-배열로-만드는-예제">다차원 배열을 1차원 배열로 만드는 예제</h2>

<p>다차원 배열이란 배열이 한개의 차원이 아닌 여러개의 차원이 되는 그런 배열을 뜻한다. 다차원 배열이 된 이상 배열의 크기는 그렇게 중요하지 않고 어느 부분이라도 확장될수 있다.</p>

<p>1차원 배열이란 [0,1,2,3,4,5]와 같은 배열을 말하며
2차원 배열은 [ [1,2,3], [4,5,6] ]과 같은 배열을 말한다.</p>

<p>그러나 다 차원 배열은 저것을 넘어선 어느 부분에서건 증가가 가능해지는데 아래와 같은 배열도 다차원 배열에 속한다</p>

<p>[ 0, [1,2, [3,2,3,1], [0,1,2,3,] ],2,3,4 [1,2,3, [4, [6] ] ] ] 과 같이 보기도 힘든 배열…도 역시 다차원 배열에 속한다.</p>

<p>그러나 이런 배열들을 1차원 배열로 바꾸기 위해서는 어떻게 해야할까?</p>

<p>말 그대로 위의 배열을 [ 0, 1, 2, 3, 3, 1 …]와 같이 말이다.</p>

<h2 id="일반적인-for문을-이용해서-푼다면">일반적인 For문을 이용해서 푼다면?</h2>

<p>그러니까 나쁜 방법부터 생각해보자 일반적인 for문을 이용한다면 어떻게 풀 수 있을까?</p>

<pre><code class="language-javascript">function Solution(target){

    var result = []

    // 만약 배열이 아니라면 이 함수를 종료
    if(!Array.isArray(target))
        return null

    // 타갯의 길이 만큼 반복
    for(var i = 0; i &lt; target.legnth; i ++){
        // 타갯의 i가 배열인지 확인
        if( !Array.isArray(  target[i] ) ){
            // 배열이 아니라면 1차원 배열에 삽입
            result.push(target[i])
        }else{
            for(var j = 0; j &lt; target[i].length; j ++){
                if( !Array.isArray(  target[i][j] ) ){
                    result.push(target[i][j])
                }
            }else{
                .
                .
                .
            }
        }
    }
}
</code></pre>

<p>와 같이 depth에 관한 정보를 모른다면 어디까지 코딩해야하는지 알 수 없다. 즉 거의 불가능에 가깝다.</p>

<p>그렇다면 어떻게 하면 효율적으로 해결할 수 있을까?</p>

<pre><code class="language-javascript">function Solution(target) {
  // 결과를 담을 변수
  var result = [];

  for (var i = 0; i &lt; target.length; i++) {
    // 어레이가 아니라면 push해주고
    if (!Array.isArray(target[i])) result.push(target[i]);
    else {
      result = result.concat(Solution(target[i]));
    }
  }

  return result;
}
</code></pre>

<p>위 처럼 해결할 수 있다.</p>]]></content><author><name></name></author><category term="개발" /><category term="Javascript" /><category term="Recursion" /><summary type="html"><![CDATA[재귀함수 (Recursion function)]]></summary></entry><entry><title type="html">나는 graphql을 이해했다</title><link href="http://localhost:4000/study/I-understand-grahpql" rel="alternate" type="text/html" title="나는 graphql을 이해했다" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>http://localhost:4000/study/I-understand-grahpql</id><content type="html" xml:base="http://localhost:4000/study/I-understand-grahpql"><![CDATA[<h2 id="graphql은-무엇일까">Graphql은 무엇일까?</h2>

<p>대다수의 블로그를 보면 마치 정말 전지전능한 실제 기술같았다. 왜냐면 꼭 파이어베이스와 같이 서버리스 플랫폼에서 제공하는 플랫폼의 ‘라이벌’이라고 얘길 해서 나는 Firebase(‘이하’ 파이어베이스) 같이 별다른 설정 없이 사용할 수 있는줄 알았다.</p>

<blockquote>
  <p>잘못된 이해였다</p>
</blockquote>

<p>실제로 Graphql과 RESTfullAPI의 설계는 많은 차이를 보이지만 결국엔 내가 컨트롤 한다는 점에선 변화가 없고 대신 라우터의 관리 파라미터의 관리가 엄청 쉬워진다는 장점이 있다.</p>

<p>기존에 JWT토큰을 발행하기 위해서 /login/createjwttoken이라는 라우터에서 파라미터를 받아서 컨트롤 하기 위해서 Node.js에 새로운 라우터를 만들고……..</p>

<p>이런 행위를 하지 않고 모든 라우터를 graphql에 묶어서 관리해주면된다.</p>

<h2 id="그럼-무엇을-잘못-이해했을까">그럼 무엇을 잘못 이해했을까?</h2>

<p>나는 Graphql을 접하기전에 파이어베이스를 먼저 접했다. 파이어베이스는 별다른 설정없이 데이터를 설계하고 스키마 설계를 필요하지도 않고 단지 그냥 그저 쓸 뿐이었다.</p>

<p>난 Graphql이 그런건줄 알았다. 대다수의 블로그 글들은 Query와 Mutaion과 같은 데이터를 불러오는 예제만 기록되어있었다.</p>

<p>Node.js에서 별다른 설치없이 데이터베이스와 연결만하면 Sequlize라는 ORM 기반 모듈처럼 데이터베이스도 알아서 만들어주고 테이블도 알아서 관리해주는줄 알았다.</p>

<blockquote>
  <p>그러나 완전히 반대였다.</p>
</blockquote>

<h2 id="그러면-내가-이해한-graphql은">그러면 내가 이해한 Graphql은?</h2>

<p>이번 개인프로젝트에 적극적으로 도입해서 모든 요청은 Graphql로 처리하고있다,</p>

<p>가장 이해하기 힘든 부분은 ‘로그인’에 대한 처리였는데 이걸 이해하고선 Graphql을 빨리 이해할 수 있었다.</p>

<p>우선 Graphql은 데이터베이스를 직접적으로 만들어주지 않는다. Resolver라는 부분을 통해서 요청이 들어오면 해당 요청을 검토하고 데이터를 컨트롤 해야한다.</p>

<pre><code class="language-javascript">export default {
  // 로그인 -&gt; JWT토큰 만들어서 token을 리턴해줌
  Query: {
    login: (_, { email, password }, ctx) =&gt; {
      console.log(ctx);
      return models.User.findByEmail({ email, password })
        .then((user) =&gt; {
          if (user.password == createHash(password)) {
            return createJWTToken(user.id, user.displayName).then((token) =&gt; {
              return { token };
            });
          } else {
            return new Error("not matched password");
          }
        })
        .catch((err) =&gt; {
          return new Error("not found user");
        });
    },
  },
};
</code></pre>

<p>위와 같이 결국 데이터를 직접 조회해서 해당 데이터를 비교후에 리턴값으로 Token이라는 기존에 저작되어있는 타입을 리턴해준다 Token의 값은 단순 String에 속한다.</p>

<pre><code class="language-javascript">type User {
        id: ID!
        email: String! @isUnique
        password: String!
        displayName: String!
    }

type Token {
    token: String!
}

type Query {
    login(email: String!, password: String!): Token
}

type Mutation {
    register(email: String!, password: String!, displayName: String!): User
}
</code></pre>

<p>결국엔 Json으로 들어온 객체를 통해 받아온 데이터를 활용해서 알맞는 리턴값을 구해서 만들어줘야한다는 점이다.</p>

<p>결국에 내가 생각했던 ‘연결만 하고 타입설정만 하면 끝’이라는 것과는 너무 큰 차이가 있었다.</p>

<h2 id="graphql을-사용하면서의-이점">Graphql을 사용하면서의 이점</h2>

<p>아무리 그래도 직접 Router를 통해서 하나하나 Post부터 시작해서 Get등 다양한 메서드를 갖는 라우터를 설계하는것보단 훨씬 작업 속도가 빨랐다.</p>

<h2 id="graphql을-앞으로도-계속-사용할건지">Graphql을 앞으로도 계속 사용할건지?</h2>

<blockquote>
  <p>네!</p>
</blockquote>

<p>당장 스텍오버플로우만 봐도 그렇듯 상당히 많은 수요가있다. 그리고 막상 사용해보니 처음 이해할때만 조금 어려웠고 막상 이해하고 나니 파일관리도 편하고 기본적으로 Apollo 라는 모듈을 사용할땐 서버를 별다른 설정을 하지 않아도 테스트할 수 있게 서버를 만들어줘서 상당히 편리했다.</p>]]></content><author><name></name></author><category term="개발" /><category term="graphql" /><category term="mysql" /><summary type="html"><![CDATA[Graphql은 무엇일까?]]></summary></entry><entry><title type="html">MongoDb를 처음 접한 내가, 잘못이해했던 RDS</title><link href="http://localhost:4000/study/I-was-wrong-understand-RDS" rel="alternate" type="text/html" title="MongoDb를 처음 접한 내가, 잘못이해했던 RDS" /><published>2018-07-13T00:00:00+09:00</published><updated>2018-07-13T00:00:00+09:00</updated><id>http://localhost:4000/study/I-was-wrong-understand-RDS</id><content type="html" xml:base="http://localhost:4000/study/I-was-wrong-understand-RDS"><![CDATA[<h2 id="mongodb를-접하다">MongoDb를 접하다</h2>

<p>그랬다. MognoDb’이하 몽고디비’를 접했었다. 그것은 내가 샀던 Node.js 책에서 저자가 정말 너무나도 추천을 했었고 당시 유행했던 ‘MEAN STACK’ 프로젝트의 구성요소 때문이기도 했었다.</p>

<p>몽고디비는 정말로 핫했고 지금도 물론 너무나도 좋은 데이터베이스임에 분명하다 NoSql중 단연 으뜸이기도 하다</p>

<p>Oracle, Mysql, Ms Sql, PostgreSQL, MongoDb라는 순위를 <a href="https://db-engines.com/en/ranking">데이터베이스 랭킹</a>에서 확인 할 수 있다.</p>

<h3 id="mongodb가-가진-장점의-이해">MongoDb가 가진 장점의 이해</h3>

<p>나는 당시에 Nosql이 가진 가장 큰 장점은 ‘확장성’이라고 생각했다. 단지 확장성 하나 때문에 Mysql을 안사용하고 몽고디비를 써야겠다고 생각했다. 그러나 이것은 정말로 큰 오해였다.</p>

<h2 id="mysql에-관심을-가지게된-계기부터">Mysql에 관심을 가지게된 계기부터</h2>

<p>나는 사실 서버도 좋아하고 프론트엔드도 좋아하는 어쩌면 잡 개발자라고 할수 있다 사실 아직은 이렇다할 정체성을 가지지 못하고 있다. 두개다 재밌기 때문인데.</p>

<p>최근 면접에서 단연코 많이 하는 질문은 ‘RDS’에 관한 이해였다.</p>

<p>RDS는 중요했다. 웹을 지탱하는 데이터베이스 중 그것은 단연 으뜸이다.</p>

<p>그러나 나는 사실 이런 RDS에 대해 자세히 이해하지 못했었는데 그것은 전혀 관심이 없기 때문이었다.</p>

<p>그러나 다음 면접을 위해선 반드시 공부해야겠다고 생각했고 최근까지도 RDS로 토이프로젝트를 만들며 배워보고있다.</p>

<h2 id="rds의-확장성">RDS의 확장성</h2>

<p>정말 확장성이 없을까?</p>

<blockquote>
  <p>그렇다</p>
</blockquote>

<p>내 개념에선 적어도 그랬다. 왜냐면 애초에 테이블을 ‘설계’해야하고 이 테이블은 사실상 바뀌기 힘들었기 때문이다.</p>

<p>Nosql을 예를 들자면 그냥 도큐먼트에 새로운 객체 하나만 추가하면 만들어지는 데이터베이스 와는 정반대로</p>

<p>‘수정’을 해야한다고 생각했기 때문이다.</p>

<blockquote>
  <p>그러나 그것은 잘못된 이해였다.
RDS를 반대로 이해한것이다.</p>
</blockquote>

<h2 id="데이터베이스의-정규화">데이터베이스의 정규화</h2>

<p>‘정규화’를 이해하지 못했기 때문에 확장성이 없다고 판단한것이었다. 데이터베이스의 정규화란 몇가지의 형식이 있으며 정말로 간단하게 설명하자면</p>

<p>기존에 내가 이해했던 RDS란 하나의 테이블의 모든 데이터를 꾸겨넣는다고 생각했다.</p>

<p>예를 들어 성적에 관한 데이터베이스를 만든다면</p>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>국어</th>
      <th>영어</th>
      <th>수학</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>종민</td>
      <td>100</td>
      <td>90</td>
      <td>100</td>
    </tr>
    <tr>
      <td>준형</td>
      <td>12</td>
      <td>32</td>
      <td>22</td>
    </tr>
  </tbody>
</table>

<p>와 같은 형식으로 만들었을 것이다.</p>

<h3 id="그러나-정규화를-이해하고-나선-조금-달라진다">그러나 정규화를 이해하고 나선 조금 달라진다.</h3>

<table>
  <thead>
    <tr>
      <th>이름</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>종민</td>
      <td>1</td>
    </tr>
    <tr>
      <td>준형</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>이라는 테이블을 하나 만들고</p>

<table>
  <thead>
    <tr>
      <th>pub_id</th>
      <th>국어</th>
      <th>영어</th>
      <th>수학</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>100</td>
      <td>90</td>
      <td>100</td>
    </tr>
    <tr>
      <td>1</td>
      <td>12</td>
      <td>32</td>
      <td>22</td>
    </tr>
  </tbody>
</table>

<p>과 같이 만들것이다.</p>

<p>pub_id란 위의 종민 준형의 id값을 가리키는 Foreign key’FK’가 된다.</p>

<blockquote>
  <p>즉 관계형 데이터베이스를 관계정 데이터베이스 답게 이해하게 된것이다.</p>
</blockquote>

<h2 id="이제는-확장성에-대해서-고민할-필요가-없다">이제는 확장성에 대해서 고민할 필요가 없다.</h2>

<p>혹시 아직도 RDS의 확장성에 대해서 고민할 수 있을까? 절대로 그래선 안된다.</p>

<blockquote>
  <p>만약 내가 새로운 데이터를 추가하고 싶다면 원 테이블을 고민하는게 아니라 새로운 테이블을 만들어 관계를 추가하면 되기 때문이다.</p>
</blockquote>]]></content><author><name></name></author><category term="개발" /><category term="RDS" /><category term="Mysql" /><summary type="html"><![CDATA[MongoDb를 접하다]]></summary></entry></feed>