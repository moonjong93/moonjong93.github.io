<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-08-24T16:47:04+09:00</updated><id>/</id><title type="html">MoongJong93</title><subtitle>웹 개발에 관한 이야기, Node.js와 Vue.js를 사용하는 개발자</subtitle><entry><title type="html">자바스크립트의 재귀함수 어떻게 이해하면 좋을까?</title><link href="/study/How-to-understand-javascript-recursion-function" rel="alternate" type="text/html" title="자바스크립트의 재귀함수 어떻게 이해하면 좋을까?" /><published>2018-08-24T00:00:00+09:00</published><updated>2018-08-24T00:00:00+09:00</updated><id>/study/How-to-understand-javascript-recursion-function</id><content type="html" xml:base="/study/How-to-understand-javascript-recursion-function">&lt;h2 id=&quot;재귀함수-recursion-function&quot;&gt;재귀함수 (Recursion function)&lt;/h2&gt;
&lt;p&gt;재귀함수는 말 그대로 함수 내에서 자기 자신을 다시 또 호출하면서 로직을 수행하는 함수를 말한다. 재귀함수를 응용하는데 있어서 많은 글들을 읽어봤지만 사실 그렇게 크게 와닿는 글은 없었던것 같다.&lt;/p&gt;

&lt;h2 id=&quot;예제-보기&quot;&gt;예제 보기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/wwbyhkx4(v=vs.94).aspx&quot;&gt;MSDN&lt;/a&gt;의 예제를 살펴보자&lt;/p&gt;

&lt;p&gt;팩토리얼에 재귀함수를 활용하는 예제인데&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function factorial(num)
{
    // If the number is less than 0, reject it.
    if (num &amp;lt; 0) {
        return -1;
    }
    // If the number is 0, its factorial is 1.
    else if (num == 0) {
        return 1;
    }
    var tmp = num;
    while (num-- &amp;gt; 2) {
        tmp *= num;
    }
    return tmp;
}

var result = factorial(8);
document.write(result);

// Output: 40320
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와같은 팩토리얼 함수를 재귀함수로 아래와같이 만들수 있다는 내용이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function factorial(num)
{
    // If the number is less than 0, reject it.
    if (num &amp;lt; 0) {
        return -1;
    }
    // If the number is 0, its factorial is 1.
    else if (num == 0) {
        return 1;
    }
    // Otherwise, call this recursive procedure again.
    else {
        return (num * factorial(num - 1));
    }
}

var result = factorial(8);
document.write(result);

// Output: 40320
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;간단한-예제-그러나-사용처는&quot;&gt;간단한 예제 그러나 사용처는?&lt;/h2&gt;
&lt;p&gt;본인도 그랬다 물론 이해는 되지만 ‘재귀함수’를 사용하면서 얻는 이점이 무엇이 있는지 사실 이해가 잘 가지 않았다.&lt;/p&gt;

&lt;p&gt;왜냐면 후자의 예제 역시 동작이 되며 모두다 같은 결과 값을 가져다 주기 때문이다.&lt;/p&gt;

&lt;p&gt;그러던 도중 타인에게 문제를 받아 해결하는 과정에서 재귀함수를 사용해 꽤 간단하게 문제를 풀어냈기에 이 예제를 본다면 다른 사람도 어느정도 도움이 될것 같아서 작성하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;다차원-배열을-1차원-배열로-만드는-예제&quot;&gt;다차원 배열을 1차원 배열로 만드는 예제&lt;/h2&gt;
&lt;p&gt;다차원 배열이란 배열이 한개의 차원이 아닌 여러개의 차원이 되는 그런 배열을 뜻한다. 다차원 배열이 된 이상 배열의 크기는 그렇게 중요하지 않고 어느 부분이라도 확장될수 있다.&lt;/p&gt;

&lt;p&gt;1차원 배열이란 [0,1,2,3,4,5]와 같은 배열을 말하며
2차원 배열은 [ [1,2,3], [4,5,6] ]과 같은 배열을 말한다.&lt;/p&gt;

&lt;p&gt;그러나 다 차원 배열은 저것을 넘어선 어느 부분에서건 증가가 가능해지는데 아래와 같은 배열도 다차원 배열에 속한다&lt;/p&gt;

&lt;p&gt;[ 0, [1,2, [3,2,3,1], [0,1,2,3,] ],2,3,4 [1,2,3, [4, [6] ] ] ] 과 같이 보기도 힘든 배열…도 역시 다차원 배열에 속한다.&lt;/p&gt;

&lt;p&gt;그러나 이런 배열들을 1차원 배열로 바꾸기 위해서는 어떻게 해야할까?&lt;/p&gt;

&lt;p&gt;말 그대로 위의 배열을 [ 0, 1, 2, 3, 3, 1 …]와 같이 말이다.&lt;/p&gt;

&lt;h2 id=&quot;일반적인-for문을-이용해서-푼다면&quot;&gt;일반적인 For문을 이용해서 푼다면?&lt;/h2&gt;
&lt;p&gt;그러니까 나쁜 방법부터 생각해보자 일반적인 for문을 이용한다면 어떻게 풀 수 있을까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Solution(target){
    
    var result = []

    // 만약 배열이 아니라면 이 함수를 종료
    if(!Array.isArray(target))
        return null

    // 타갯의 길이 만큼 반복
    for(var i = 0; i &amp;lt; target.legnth; i ++){
        // 타갯의 i가 배열인지 확인
        if( !Array.isArray(  target[i] ) ){
            // 배열이 아니라면 1차원 배열에 삽입
            result.push(target[i])
        }else{
            for(var j = 0; j &amp;lt; target[i].length; j ++){
                if( !Array.isArray(  target[i][j] ) ){
                    result.push(target[i][j])
                }
            }else{
                .
                .
                .
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같이 depth에 관한 정보를 모른다면 어디까지 코딩해야하는지 알 수 없다. 즉 거의 불가능에 가깝다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 하면 효율적으로 해결할 수 있을까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Solution(target){
    // 결과를 담을 변수
    var result = [];
    
    for(var i =0 ; i &amp;lt; target.length; i++){
        // 어레이가 아니라면 push해주고 
        if( !Array.isArray( target[i] ) )
            result.push( target[i] )
        else{
            result = result.concat( Solution( target[i] ) )
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 처럼 해결할 수 있다.&lt;/p&gt;</content><author><name></name></author><category term="Javascript" /><category term="Recursion" /><summary type="html">재귀함수 (Recursion function) 재귀함수는 말 그대로 함수 내에서 자기 자신을 다시 또 호출하면서 로직을 수행하는 함수를 말한다. 재귀함수를 응용하는데 있어서 많은 글들을 읽어봤지만 사실 그렇게 크게 와닿는 글은 없었던것 같다.</summary></entry><entry><title type="html">나는 graphql을 이해했다</title><link href="/study/I-understand-grahpql" rel="alternate" type="text/html" title="나는 graphql을 이해했다" /><published>2018-08-16T00:00:00+09:00</published><updated>2018-08-16T00:00:00+09:00</updated><id>/study/I-understand-grahpql</id><content type="html" xml:base="/study/I-understand-grahpql">&lt;h2 id=&quot;graphql은-무엇일까&quot;&gt;Graphql은 무엇일까?&lt;/h2&gt;
&lt;p&gt;대다수의 블로그를 보면 마치 정말 전지전능한 실제 기술같았다. 왜냐면 꼭 파이어베이스와 같이 서버리스 플랫폼에서 제공하는 플랫폼의 ‘라이벌’이라고 얘길 해서 나는 Firebase(‘이하’ 파이어베이스) 같이 별다른 설정 없이 사용할 수 있는줄 알았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;잘못된 이해였다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실제로 Graphql과 RESTfullAPI의 설계는 많은 차이를 보이지만 결국엔 내가 컨트롤 한다는 점에선 변화가 없고 대신 라우터의 관리 파라미터의 관리가 엄청 쉬워진다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;기존에 JWT토큰을 발행하기 위해서 /login/createjwttoken이라는 라우터에서 파라미터를 받아서 컨트롤 하기 위해서 Node.js에 새로운 라우터를 만들고……..&lt;/p&gt;

&lt;p&gt;이런 행위를 하지 않고 모든 라우터를 graphql에 묶어서 관리해주면된다.&lt;/p&gt;

&lt;h2 id=&quot;그럼-무엇을-잘못-이해했을까&quot;&gt;그럼 무엇을 잘못 이해했을까?&lt;/h2&gt;

&lt;p&gt;나는 Graphql을 접하기전에 파이어베이스를 먼저 접했다. 파이어베이스는 별다른 설정없이 데이터를 설계하고 스키마 설계를 필요하지도 않고 단지 그냥 그저 쓸 뿐이었다.&lt;/p&gt;

&lt;p&gt;난 Graphql이 그런건줄 알았다. 대다수의 블로그 글들은 Query와 Mutaion과 같은 데이터를 불러오는 예제만 기록되어있었다.&lt;/p&gt;

&lt;p&gt;Node.js에서 별다른 설치없이 데이터베이스와 연결만하면 Sequlize라는 ORM 기반 모듈처럼 데이터베이스도 알아서 만들어주고 테이블도 알아서 관리해주는줄 알았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 완전히 반대였다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그러면-내가-이해한-graphql은&quot;&gt;그러면 내가 이해한 Graphql은?&lt;/h2&gt;

&lt;p&gt;이번 개인프로젝트에 적극적으로 도입해서 모든 요청은 Graphql로 처리하고있다,&lt;/p&gt;

&lt;p&gt;가장 이해하기 힘든 부분은 ‘로그인’에 대한 처리였는데 이걸 이해하고선 Graphql을 빨리 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;우선 Graphql은 데이터베이스를 직접적으로 만들어주지 않는다. Resolver라는 부분을 통해서 요청이 들어오면 해당 요청을 검토하고 데이터를 컨트롤 해야한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default {
    // 로그인 -&amp;gt; JWT토큰 만들어서 token을 리턴해줌 
Query: { 
        login: (_, {email, password}, ctx) =&amp;gt; {
            console.log(ctx)
            return models.User.findByEmail({email, password})
            .then( (user) =&amp;gt; {
                if(user.password == createHash(password)){
                    return createJWTToken(user.id, user.displayName)
                    .then((token) =&amp;gt; {
                        return { token }
                    })
                }else{
                    return new Error('not matched password')
                }
            })
            .catch((err) =&amp;gt; {
                return new Error('not found user')
            })
        },
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 결국 데이터를 직접 조회해서 해당 데이터를 비교후에 리턴값으로 Token이라는 기존에 저작되어있는 타입을 리턴해준다 Token의 값은 단순 String에 속한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;type User {
        id: ID!
        email: String! @isUnique
        password: String!
        displayName: String!
    }

type Token {
    token: String!
}

type Query {
    login(email: String!, password: String!): Token
}

type Mutation {
    register(email: String!, password: String!, displayName: String!): User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국엔 Json으로 들어온 객체를 통해 받아온 데이터를 활용해서 알맞는 리턴값을 구해서 만들어줘야한다는 점이다.&lt;/p&gt;

&lt;p&gt;결국에 내가 생각했던 ‘연결만 하고 타입설정만 하면 끝’이라는 것과는 너무 큰 차이가 있었다.&lt;/p&gt;

&lt;h2 id=&quot;graphql을-사용하면서의-이점&quot;&gt;Graphql을 사용하면서의 이점&lt;/h2&gt;
&lt;p&gt;아무리 그래도 직접 Router를 통해서 하나하나 Post부터 시작해서 Get등 다양한 메서드를 갖는 라우터를 설계하는것보단 훨씬 작업 속도가 빨랐다.&lt;/p&gt;

&lt;h2 id=&quot;graphql을-앞으로도-계속-사용할건지&quot;&gt;Graphql을 앞으로도 계속 사용할건지?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;네!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;당장 스텍오버플로우만 봐도 그렇듯 상당히 많은 수요가있다. 그리고 막상 사용해보니 처음 이해할때만 조금 어려웠고 막상 이해하고 나니 파일관리도 편하고 기본적으로 Apollo 라는 모듈을 사용할땐 서버를 별다른 설정을 하지 않아도 테스트할 수 있게 서버를 만들어줘서 상당히 편리했다.&lt;/p&gt;</content><author><name></name></author><category term="graphql" /><category term="mysql" /><summary type="html">Graphql은 무엇일까? 대다수의 블로그를 보면 마치 정말 전지전능한 실제 기술같았다. 왜냐면 꼭 파이어베이스와 같이 서버리스 플랫폼에서 제공하는 플랫폼의 ‘라이벌’이라고 얘길 해서 나는 Firebase(‘이하’ 파이어베이스) 같이 별다른 설정 없이 사용할 수 있는줄 알았다.</summary></entry><entry><title type="html">MongoDb를 처음 접한 내가, 잘못이해했던 RDS</title><link href="/study/I-was-wrong-understand-RDS" rel="alternate" type="text/html" title="MongoDb를 처음 접한 내가, 잘못이해했던 RDS" /><published>2018-07-13T00:00:00+09:00</published><updated>2018-07-13T00:00:00+09:00</updated><id>/study/I-was-wrong-understand-RDS</id><content type="html" xml:base="/study/I-was-wrong-understand-RDS">&lt;h2 id=&quot;mongodb를-접하다&quot;&gt;MongoDb를 접하다&lt;/h2&gt;
&lt;p&gt;그랬다. MognoDb’이하 몽고디비’를 접했었다. 그것은 내가 샀던 Node.js 책에서 저자가 정말 너무나도 추천을 했었고 당시 유행했던 ‘MEAN STACK’ 프로젝트의 구성요소 때문이기도 했었다.&lt;/p&gt;

&lt;p&gt;몽고디비는 정말로 핫했고 지금도 물론 너무나도 좋은 데이터베이스임에 분명하다 NoSql중 단연 으뜸이기도 하다&lt;/p&gt;

&lt;p&gt;Oracle, Mysql, Ms Sql, PostgreSQL, MongoDb라는 순위를 &lt;a href=&quot;https://db-engines.com/en/ranking&quot;&gt;데이터베이스 랭킹&lt;/a&gt;에서 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;mongodb가-가진-장점의-이해&quot;&gt;MongoDb가 가진 장점의 이해&lt;/h3&gt;
&lt;p&gt;나는 당시에 Nosql이 가진 가장 큰 장점은 ‘확장성’이라고 생각했다. 단지 확장성 하나 때문에 Mysql을 안사용하고 몽고디비를 써야겠다고 생각했다. 그러나 이것은 정말로 큰 오해였다.&lt;/p&gt;

&lt;h2 id=&quot;mysql에-관심을-가지게된-계기부터&quot;&gt;Mysql에 관심을 가지게된 계기부터&lt;/h2&gt;
&lt;p&gt;나는 사실 서버도 좋아하고 프론트엔드도 좋아하는 어쩌면 잡 개발자라고 할수 있다 사실 아직은 이렇다할 정체성을 가지지 못하고 있다. 두개다 재밌기 때문인데.&lt;/p&gt;

&lt;p&gt;최근 면접에서 단연코 많이 하는 질문은 ‘RDS’에 관한 이해였다.&lt;/p&gt;

&lt;p&gt;RDS는 중요했다. 웹을 지탱하는 데이터베이스 중 그것은 단연 으뜸이다.&lt;/p&gt;

&lt;p&gt;그러나 나는 사실 이런 RDS에 대해 자세히 이해하지 못했었는데 그것은 전혀 관심이 없기 때문이었다.&lt;/p&gt;

&lt;p&gt;그러나 다음 면접을 위해선 반드시 공부해야겠다고 생각했고 최근까지도 RDS로 토이프로젝트를 만들며 배워보고있다.&lt;/p&gt;

&lt;h2 id=&quot;rds의-확장성&quot;&gt;RDS의 확장성&lt;/h2&gt;
&lt;p&gt;정말 확장성이 없을까?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;그렇다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내 개념에선 적어도 그랬다. 왜냐면 애초에 테이블을 ‘설계’해야하고 이 테이블은 사실상 바뀌기 힘들었기 때문이다.&lt;/p&gt;

&lt;p&gt;Nosql을 예를 들자면 그냥 도큐먼트에 새로운 객체 하나만 추가하면 만들어지는 데이터베이스 와는 정반대로&lt;/p&gt;

&lt;p&gt;‘수정’을 해야한다고 생각했기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 그것은 잘못된 이해였다.
RDS를 반대로 이해한것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;데이터베이스의-정규화&quot;&gt;데이터베이스의 정규화&lt;/h2&gt;
&lt;p&gt;‘정규화’를 이해하지 못했기 때문에 확장성이 없다고 판단한것이었다. 데이터베이스의 정규화란 몇가지의 형식이 있으며 정말로 간단하게 설명하자면&lt;/p&gt;

&lt;p&gt;기존에 내가 이해했던 RDS란 하나의 테이블의 모든 데이터를 꾸겨넣는다고 생각했다.&lt;/p&gt;

&lt;p&gt;예를 들어 성적에 관한 데이터베이스를 만든다면&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;국어&lt;/th&gt;
      &lt;th&gt;영어&lt;/th&gt;
      &lt;th&gt;수학&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;종민&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;준형&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;와 같은 형식으로 만들었을 것이다.&lt;/p&gt;

&lt;h3 id=&quot;그러나-정규화를-이해하고-나선-조금-달라진다&quot;&gt;그러나 정규화를 이해하고 나선 조금 달라진다.&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;종민&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;준형&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이라는 테이블을 하나 만들고&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;pub_id&lt;/th&gt;
      &lt;th&gt;국어&lt;/th&gt;
      &lt;th&gt;영어&lt;/th&gt;
      &lt;th&gt;수학&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;과 같이 만들것이다.&lt;/p&gt;

&lt;p&gt;pub_id란 위의 종민 준형의 id값을 가리키는 Foreign key’FK’가 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉 관계형 데이터베이스를 관계정 데이터베이스 답게 이해하게 된것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;이제는-확장성에-대해서-고민할-필요가-없다&quot;&gt;이제는 확장성에 대해서 고민할 필요가 없다.&lt;/h2&gt;
&lt;p&gt;혹시 아직도 RDS의 확장성에 대해서 고민할 수 있을까? 절대로 그래선 안된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 내가 새로운 데이터를 추가하고 싶다면 원 테이블을 고민하는게 아니라 새로운 테이블을 만들어 관계를 추가하면 되기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="RDS" /><category term="Mysql" /><summary type="html">MongoDb를 접하다 그랬다. MognoDb’이하 몽고디비’를 접했었다. 그것은 내가 샀던 Node.js 책에서 저자가 정말 너무나도 추천을 했었고 당시 유행했던 ‘MEAN STACK’ 프로젝트의 구성요소 때문이기도 했었다.</summary></entry><entry><title type="html">Firestore 이해하기</title><link href="/development/firestore-knowlage" rel="alternate" type="text/html" title="Firestore 이해하기" /><published>2018-06-25T00:00:00+09:00</published><updated>2018-06-25T00:00:00+09:00</updated><id>/development/firestore-knowlage</id><content type="html" xml:base="/development/firestore-knowlage">&lt;h2 id=&quot;순서&quot;&gt;순서&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Firebase의 등장 배경&lt;/li&gt;
  &lt;li&gt;그래서 등장한 Firestore&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;firebase의-등장-배경&quot;&gt;Firebase의 등장 배경&lt;/h2&gt;
&lt;p&gt;정말 간단히 말하자면 클라이언트 개발자의 새로운 개발을 위해 생겼다고 볼 수 있다. 지금은 물론 구글의 인수 이후로 정말 날개를 단듯 MLkit이라던지 내부적으로도 많은 업데이트를 진행하고 있지만 기본적인 출발은 ‘시작을 빠르게’라는 취지로 누구나 웹 개발, 앱 개발을 더 이상 서버까지 고민하지 말고 만들자. 라는 출발이었다&lt;/p&gt;

&lt;p&gt;그 출발은 괜찮았다 Firebase(이하 ‘파이어베이스’)의 요금은 정말로 합리적이었으며 내부적으로 제공하는 Storage와 Authentications등은 데이터베이스 하나로 파이어베이스를 사용하는 것이 아니라 그 외에 부가적인 부분에서도 많은 이득을 챙길 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;나와 같은 경우 처음 파이어베이스에 대해서 듣게 되었을땐 ‘정말로 이런 서비스가 가능한가?’라는 의문도 품었었다.&lt;/p&gt;

&lt;p&gt;그러나 매끄럽게 가능했다. 파이어베이스 실시간 데이터베이스는 더욱 더 그러했다. 별다른 서버사이드 코드없이도 이제 프로토타입 그리고 어느정도 규모있는 앱까지는 충분히 만들어 볼만 했다.&lt;/p&gt;

&lt;h3 id=&quot;어느정도에-주목하자&quot;&gt;‘어느정도’에 주목하자&lt;/h3&gt;
&lt;p&gt;물론 이 글을 읽는 당신이 개인 개발자고 개인으로서 결과물이 어느정도 훌륭해서 금전적인 이득을 얻는 수준의 ‘규모’에서는 전혀 문제될게 없었다.&lt;/p&gt;

&lt;p&gt;그래서인지 해외에서도 개인이 앱을 만들어 먹고사는 ‘개인 개발자’에게 있어서는 정말로 괜찮은 서비스이었다.&lt;/p&gt;

&lt;p&gt;왜 ‘규모’에 대해서 언급하냐면 Firebase의 데이터베이스는 괘랄하다 못해서 사실 별로였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;아니 괜찮다며;;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;아니 정말 괜찮은 서비스임에 분명했지만, Query의 부재 그리고 속도 등의 이슈로 규모가 조금 있는 서비스라면 사용을 자제하는것이 좋다고 생각이 들었다.&lt;/p&gt;

&lt;h1 id=&quot;그래서-등장한-firestore&quot;&gt;그래서 등장한 Firestore&lt;/h1&gt;
&lt;p&gt;지금은 물론 ‘Beta’서비스 이긴 하지만 말 그대로 ‘등 - 장’했다.&lt;/p&gt;

&lt;p&gt;모름지기 개발자라면 ‘프레임워크, 라이브러리에 대한 의존성이 없어야해!’라고 말씀하셨던 선배님의 말씀이 떠오르지만 Firestore(이하 ‘파이어스토어’)에는 조금 의존을 해보고 싶었다.&lt;/p&gt;

&lt;p&gt;그동안 존재하지 않았던 Query와 더욱 더 강력해진 Rule과 이제 더 이상은 파이어베이스를 사용하지 않아도 괜찮다!&lt;/p&gt;

&lt;p&gt;파이어스토어의 몇가지 특징을 얘기하자면&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빠른 NosSql 데이터 베이스
    &lt;ul&gt;
      &lt;li&gt;콜렉션과 도큐먼트 기반의 확장성이 용이한 데이터 베이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Query의 사용이 가능함 (Admin-sdk에서는 기능이 더욱 강함 ‘Skip’ 등)&lt;/li&gt;
  &lt;li&gt;파이어베이스부터 단련된 Rule!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등을 대표적으로 얘기할 수 있는데&lt;/p&gt;

&lt;p&gt;이런 데이터베이스를 서버사이드 코드 없이 사용할 수 있다는것은 정말 개발자로 하여금 많은 일을 가능하게 만든다.&lt;/p&gt;

&lt;p&gt;가령 기존 파이어베이스로 게시판을 만든다고 했다면 당연히 하지말라고 얘기했을 것이다 차라리 페이스북의 &lt;a href=&quot;https://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt;을 사용하라고 하고싶었다.&lt;/p&gt;

&lt;p&gt;그러나 이번엔 다르다 빠른 NoSql의 데이터베이스는 기존 정적인 게시판이 아닌 정말 넓은 확장성을 자랑하는 게시판을 만들 수도 있으며&lt;/p&gt;

&lt;p&gt;게시판에서 빠질수 없는 검색등의 기능도 향상된 Query로 만들수 있으며&lt;/p&gt;

&lt;p&gt;거기다가 Functions의 연동을 통한다면 기존에 우리가 사용하던 데이터베이스들에 내장되어있던 Skip등의 기능이 사용가능하다는 점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;내가-생각하는-가장-중요한-rule&quot;&gt;내가 생각하는 가장 중요한 ‘Rule’&lt;/h3&gt;
&lt;p&gt;그러나 파이어베이스, 스토어 사용에 있어서 가장 중요한 점은 Rule이다 바로 Rule이 Rule을 어떻게 사용하느냐에 따라 여러분의 서비스는 굳이 의미 없는 파이어스토어 사용이 될 수 도있으며 반대로 매우 매끄러운 사용이 가능해진다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;고작 Rule하나로?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다 Rule은 상당히 중요하다. Rule이 파이어스토어의 존재 이유라고 할수 있을 정도로 중요하다. 예를들자면 당신의 블로그에 설정은 당신만이 할 수 있어야만 한다. 이것을 서버사이드에서 처리하자면&lt;/p&gt;

&lt;p&gt;요즘 유행하는 Token방식의 인증으로 매기자면 Token 내부에 예를들면 ‘isAdmin’이라는 변수를 만들어놓고 새로 들어온 요청에 한해서 이것을 검증을 해서 그 다음 로직을 실행…..하게 해야한다.&lt;/p&gt;

&lt;p&gt;그러나 파이어스토어는 이런 검증을 Rule에서 해결 가능하다. 요청하는 유저의 UID값을 받아온 뒤 Rule 내부에서 또 다시 Get을 한다음에 해당 블로그의 주인만 가려놓고 만약 맞다면 Allow를 아니라면 딱히 코드를 작성하지 않아도 Permission 에러를 뿜으며 실행되지 않을것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;응? 적고 보니까 Token 방식이 더 간단하네?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다 당신이 ‘서버사이드’를 조금 공부했다면 사실 위에 방법이 더욱 쉬울 것이다. 나도 그랬다 사실 처음엔 이해가 안됐고 오히려 개발 시간이 서버를 갖는 것보다 오래 걸리기 때문에 짜증도 났다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 분명한건 이것은 서버의 관리 없이도 돌아간다는 점이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간혹 ‘서버리스’에 대해서 언급하면 꼭&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그걸 왜함?? 어차피 서버 규모 커지면 그냥 서버가 더 이득임&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 말을 찾아 볼 수 있는데 서버 개발자의 월급은 하늘에서 떨어지는줄 아는 사람이 많다. 생각보다 서버개발자의 임금은 높다. 데이터베이스를 매끄럽게 설계해야하는 그들은 당연히 받아가야할 임금을 받아가는 것이고 아까는 정말 단순하게 Token으로 인증하는 것을 말했지만 실제 데이터베이스 설계에선 어쩌면 더욱 많은 절차가 필요할지도 모른다.&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;
&lt;p&gt;일단 함 써보세요 진짜 Rule만 잘 이해하면 이만한 서버리스 프로젝트가 없을겁니다.&lt;/p&gt;

&lt;p&gt;그러나 최근 AWS에 &lt;a href=&quot;https://aws.amazon.com/ko/appsync/&quot;&gt;AppSync&lt;/a&gt;가 GraphQL을 도입해 비슷한 서비스를 하고 있으니 한번 찾아보시는 것도 추천합니다.&lt;/p&gt;</content><author><name></name></author><category term="서버리스" /><category term="Firebase" /><category term="Firestore" /><summary type="html">순서 Firebase의 등장 배경 그래서 등장한 Firestore</summary></entry><entry><title type="html">Tac.photos를 개발이야기 - 배운게 많다</title><link href="/career/tac-photos-develop-after" rel="alternate" type="text/html" title="Tac.photos를 개발이야기 - 배운게 많다" /><published>2018-04-23T00:00:00+09:00</published><updated>2018-04-23T00:00:00+09:00</updated><id>/career/tac-photos-develop-after</id><content type="html" xml:base="/career/tac-photos-develop-after">&lt;h2 id=&quot;시작하기-앞서&quot;&gt;시작하기 앞서&lt;/h2&gt;
&lt;p&gt;올해에 들어 SPA를 접하고 여러가지 개발을 하면서 꼭 개인프로젝트 하나를 해야겠다는 생각을 했다. 시작은 정말 거대 했다.&lt;/p&gt;

&lt;p&gt;애초에 계획은&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그인
    &lt;ul&gt;
      &lt;li&gt;Token을 활용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Serverless
    &lt;ul&gt;
      &lt;li&gt;모든 부분에 Serverless 적용&lt;/li&gt;
      &lt;li&gt;S3에 업로드 하며 당연히 썸네일도 필요할것이라 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;태그 검색&lt;/li&gt;
  &lt;li&gt;비밀 이미지&lt;/li&gt;
  &lt;li&gt;등등..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등 상당히 많은 계획과 방대한 양의 기획이 있었다. 실제로 로그인도 구현했으며 이메일 인증은 AWS의 SES를 통한 메읿 발송과 Nodemailer를 활용해 나름 멋스럽게 Table단위의 폼도 적용해서 보내기 까지 만들었다..&lt;/p&gt;

&lt;p&gt;그러나 결과적으로 모든걸 다 없애고 그냥 이미지 업로드만 냅두고 출시하게 되었다는 것이다… 상당히 애통하지만 몇가지 큰 이유들이 있었다.&lt;/p&gt;

&lt;h3 id=&quot;누가-쓰겠어&quot;&gt;누가 쓰겠어?&lt;/h3&gt;
&lt;p&gt;처음 계획은 이미지를 누구나 쉽게 공유하고 업로드 이후에 간단한 링크를 만들어 &lt;a href=&quot;https://imguar.com&quot;&gt;imguar&lt;/a&gt;과 같은 사이트 이지만 약간 한국의 느낌과 맞추고 싶었고 실제로 그게 정말 잘 될것 같다고 생각했다.&lt;/p&gt;

&lt;p&gt;그러나 몇가지 문제에 부딪혔다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;비용&lt;/li&gt;
  &lt;li&gt;디자인&lt;/li&gt;
  &lt;li&gt;홍보&lt;/li&gt;
  &lt;li&gt;쓰고자 하는 동기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 어느것도 충족할 수 없었다. 비용에 따른 문제를 고민하면서 서버도 고민하고 거기다가 가끔 뿜어져나오는 Serverless-http 와 그외 데이터베이스 등 많은 연동에서의 오류는 어느순간 나에게 이 프로젝트를 포기하라고 소리쳤다.&lt;/p&gt;

&lt;h2 id=&quot;무엇을-개발도중에-없앴나&quot;&gt;무엇을 개발도중에 없앴나?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i.tac.photos/p/rJmAmJj3M.png&quot; alt=&quot;없애버린 것들 중 하나&quot; /&gt;
그렇게 없애버린것에는 많은 것이 있었다. 대표적으로 로그인이 그렇다 소셜로그인은 Hello.js를 통해 서버에는 오로지 유저의 Email과 어떤 종류의 소셜로 로그인 했는지만 반영해서 혹시 가입되어 있지 않는 유저라면 닉네임 설정으로 넘어가게 되었고&lt;/p&gt;

&lt;p&gt;이메일 회원가입은 가입 요청과 동시에 AWS SES를 통해 이메일을 발송해서 허락이 나야만 로그인 할 수 있었다.&lt;/p&gt;

&lt;p&gt;그 외에도 이미지 태깅 검색부터 상당히 많이 부분을 아니 사실 다 날렸다고 보면된다..&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;빠르게 버리는것도 도움이 된다고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그래서-무엇을-했나&quot;&gt;그래서 무엇을 했나?&lt;/h2&gt;
&lt;p&gt;하지만 이 프로젝트를 중간에 포기했더래도(물론 그러지 않았지만) 상당히 배운게 많았다 우선 SPA앱이 가지는 한계와 이것을 극복하기 위한 노력들.. 예를들면 Cloudfront에서는 Vue Router를 403즉 없는 페이지로 인식하는데 그런 페이지의 처리 부터 시작해서 ssl의 적용 그리고 서비스워커 템플릿을 이용했을때의 단점 등… 사실 배운것만 생각하면 최고의 프로젝트였다.&lt;/p&gt;

&lt;h3 id=&quot;무엇을-배웠을까&quot;&gt;무엇을 배웠을까?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;SPA
    &lt;ul&gt;
      &lt;li&gt;라우터에 이동전 파라미터를 주고 받을때의 일&lt;/li&gt;
      &lt;li&gt;SPA앱을 구축하는데 특히 Head 태그를 관리하는 일&lt;/li&gt;
      &lt;li&gt;데이터를 변경하고 가져올때 제대로 된 구조화를 하지 않으면 오히려 내가 힘들다는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AWS
    &lt;ul&gt;
      &lt;li&gt;Route 53
        &lt;ul&gt;
          &lt;li&gt;Api gateWay의 Custom doamin을 위해서.&lt;/li&gt;
          &lt;li&gt;S3의 버킷 접근을 좀더 용이하게 만들기 위해서.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;S3
        &lt;ul&gt;
          &lt;li&gt;S3에서 버킷 URL을 짧게하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CloudFront
        &lt;ul&gt;
          &lt;li&gt;SPA앱은 존재하지 않는 파일을 요청하니 무조건 403을 내뿜기에 여러가지 세팅이 필요했다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lambda
        &lt;ul&gt;
          &lt;li&gt;serverless-http를 사용할거면 람다에서 세팅을 하는 경우는 거의 없으며 대부분은 Serverelss.yml을 통해서 해결해야한다 (버킷 억세스 권한 등등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그외
    &lt;ul&gt;
      &lt;li&gt;Token 인증
        &lt;ul&gt;
          &lt;li&gt;토큰 인증은 앞으로 대다수의 Session 방식을 사용하고 있는 웹에서 앞으로 지향해야할 방향이라고 생각한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Vuex
        &lt;ul&gt;
          &lt;li&gt;MVC패턴을 벗어나 Redux패턴 즉 Store 기반의 웹은 처음 도입하기에 조금 꺼려졌지만 특히 User의 정보를 담아 다양한 컴포넌트에서 활용을 하면서 사용하니까 너무나도 필요한 존재라는 것을 알게되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금 생각나는 것만 손에 꼽아도 상당히 많은 것들을 배울 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.tac.photos/p/Skx0M1o3f.png&quot; alt=&quot;고민의 흔적들&quot; /&gt;
상당히 많은 고민의 흔적들…&lt;/p&gt;

&lt;h2 id=&quot;다음프로젝트는&quot;&gt;다음프로젝트는?&lt;/h2&gt;
&lt;p&gt;무조건 Firebase를 쓸 생각이다. 데이터베이스를 관리하며 SPA앱을 만들고 거기다가 서버사이드의 RESTful API를 만들며 작업하는건 상당히 많은 시간이 걸린다는 것을 다시 한번 깨우쳤다.&lt;/p&gt;

&lt;p&gt;물론 graphQL을 한번 써서 프로젝트를 해보고 싶긴하지만 다음 프로젝트는 절대로 아니다. 앞으로의 개인프로젝트는 단순히 나의 포트폴리오 용도로 만드는것이 아니라 진짜 수익이 나는 괜찮은 앱을 만들어보고 싶기에 우선은 보여지는 프론트엔드 부분에 많은 고민을 할애하고 싶고 또 기획에 많은 고민을 하고 싶다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;서버리스 프로젝트는 너무나도 정말 최고였다. EC2서버를 운영할땐 스케쥴도 상당히 많이 체크해야 했고 동시접속을 얼마나 견딜 수 있을지 동일 요청을 얼마나 버틸지 등 많은 부분을 고민 해야 했다.&lt;/p&gt;

&lt;p&gt;앞으로의 웹은 RESTful이 대세가 이룰것이라고 확신한다 아니 100%다. 물론 과거에는 Node.js개발자나 PHP등 서버사이드 개발자가 해야할 일이 서버관리와 유연한 데이터베이스를 설계하는 일 이었다면&lt;/p&gt;

&lt;p&gt;이제는 분명히 프론트엔드와 백엔드의 무게가 동등 해지고 있다고 생각이 들었다.&lt;/p&gt;

&lt;p&gt;웹을 만든다, 라는 생각을 하면 나는 정말 무조건 드는 생각이 있는데 바로 어떻게 하면 내 서버자원을 유저가 최대한 적게 사용할까?? 라는 고민이었다. 이 고민은 나의 첫 프로젝트였던 Overdoc - 오버워치 데이터 제공 웹을 개발할때도 했던 생각이었는데&lt;/p&gt;

&lt;p&gt;나는 죽어도 내 서버를 호락호락하게…크흠 아무튼 최대한 서버 요청은 적을수록 좋다고 생각한다. 지금까지도 그렇게 생각해왔지만 이번 프로젝트를 하고 나서는 정말 그런 생각이 더욱 커졌다.&lt;/p&gt;

&lt;p&gt;앞으로의 RESTful기반 웹사이트는 당연히 서버리스가 좋다고 생각하고 이런 서버로의 요청을 조금이라고 덜 하기 위해서는 무조건적으로 프론트사이드에서 요청을 최소화 하기 위한 작업들을 많이 해줘야한다고 생각한다.&lt;/p&gt;

&lt;p&gt;그리고 아무래도 이 프로젝트는 그동안 블로그에 글을 작성하며 이미지 업로드 하기가 귀찮았는데.. 그 용도로 쓰면 될것같다.&lt;/p&gt;

&lt;p&gt;혹시라도 이 글을 읽는 분이 계신다면 &lt;a href=&quot;http://tac.photos&quot;&gt;Tac.phtoos&lt;/a&gt;한번 접속해주는 것도…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 프로젝트로 정말 많은걸 배웠다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="Node.js" /><category term="S3" /><category term="Lambda" /><category term="vue.js" /><summary type="html">시작하기 앞서 올해에 들어 SPA를 접하고 여러가지 개발을 하면서 꼭 개인프로젝트 하나를 해야겠다는 생각을 했다. 시작은 정말 거대 했다.</summary></entry><entry><title type="html">AWS의 S3에 CNAME을 연결하기</title><link href="/AWS/how-to-Interlink-s3-and-cname" rel="alternate" type="text/html" title="AWS의 S3에 CNAME을 연결하기" /><published>2018-03-29T00:00:00+09:00</published><updated>2018-03-29T00:00:00+09:00</updated><id>/AWS/how-to-Interlink-s3-and-cname</id><content type="html" xml:base="/AWS/how-to-Interlink-s3-and-cname">&lt;h2 id=&quot;왜&quot;&gt;왜?&lt;/h2&gt;
&lt;p&gt;버킷을 처음 생성해 그 도메인 그대로 사용하면 상당히 긴 도메인이 나온다. 내가 만들고 있는 프로젝트에 이미지를 공유하는게 주된 목적인데 EX)https://s3.amazonaws.com/test.tac.photos/DASNKFDSANf134ia9s90fd.jpeg 이렇게나 긴 도메인은 보기도 힘들고 복사해서도 길이가 너무 길어서 편하자고 사용한 내 웹사이트에서 오히려&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;왜 이따구로 주소가 길어??&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 불편함을 느낄것 같았다.&lt;/p&gt;

&lt;h2 id=&quot;준비&quot;&gt;준비&lt;/h2&gt;
&lt;p&gt;우선 버킷의 생성이 필요하다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;내가 원하는 도메인을 구매한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://kr.godaddy.com/&quot;&gt;GoDaddy&lt;/a&gt;를 추천한다.&lt;/li&gt;
      &lt;li&gt;참고로 나는 GoDaddy에서 구매후 네임서버를 ROUTE53으로 이전해서 사용중이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;버킷은 내가 사용하려고 하는 도메인의 주소와 일치하게 해서 생성
    &lt;ul&gt;
      &lt;li&gt;예) 버킷을 test.domain.com으로 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 구매와 생성이 끝났다면 거의 모든일을 해냈다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;버킷에 접속한다. (AWS 관리페이지를 통해서)&lt;/li&gt;
  &lt;li&gt;내가 만든 버킷에 들어간다.&lt;/li&gt;
  &lt;li&gt;버킷의 속성을 클릭한다.&lt;/li&gt;
  &lt;li&gt;‘정적 웹 사이트 호스팅’을 클릭한다.&lt;/li&gt;
  &lt;li&gt;‘이 버킷을 사용하여 웹 사이트를 호스팅합니다’를 체크
    &lt;ul&gt;
      &lt;li&gt;인덱스 문서에는 index.html&lt;/li&gt;
      &lt;li&gt;오류 문서에는 error.html을 입력&lt;/li&gt;
      &lt;li&gt;(실제 파일이 존재하지 않아도 된다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저장&lt;/li&gt;
  &lt;li&gt;다시 ‘정적 웹 사이트 호스팅’을 클릭&lt;/li&gt;
  &lt;li&gt;상단에 엔드포인트를 복사&lt;/li&gt;
  &lt;li&gt;현재 가지고있는 도메인의 관리 서비스로 이동&lt;/li&gt;
  &lt;li&gt;CNAME으로 등록
    &lt;ul&gt;
      &lt;li&gt;예) test.domain.com이라는 이름으로 CNAME이 가르키는 주소를 아까 복사한 엔드포인트 ‘test.test.com.s3-website-us-east-1.amazonaws.com’와 같은 URL을 입력해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5분 정도 기다리면 내가 새로 업로드하는 어떤 이미지도 test.domain.com/test.jpg로 접근이 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;물론 요청을 리다이렉션해서 2개의 버킷을 생성후 하나는 오로지 리다이렉션 정보만 담게도 설정이 가능하다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;만약 기존에 사용중인 S3 버킷이 있다면.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나 제일 처음부터 한다면 위에 나와있는 대로 하는게 좋을것 같다.&lt;/p&gt;</content><author><name></name></author><category term="AWS" /><category term="S3" /><category term="DNS" /><summary type="html">왜? 버킷을 처음 생성해 그 도메인 그대로 사용하면 상당히 긴 도메인이 나온다. 내가 만들고 있는 프로젝트에 이미지를 공유하는게 주된 목적인데 EX)https://s3.amazonaws.com/test.tac.photos/DASNKFDSANf134ia9s90fd.jpeg 이렇게나 긴 도메인은 보기도 힘들고 복사해서도 길이가 너무 길어서 편하자고 사용한 내 웹사이트에서 오히려</summary></entry><entry><title type="html">Google의 WEBP는 이미지의 용량을 얼마나 줄여줄까?</title><link href="/development/serverless/Google-webp-how-many-less" rel="alternate" type="text/html" title="Google의 WEBP는 이미지의 용량을 얼마나 줄여줄까?" /><published>2018-03-12T00:00:00+09:00</published><updated>2018-03-12T00:00:00+09:00</updated><id>/development/serverless/Google-webp-how-many-less</id><content type="html" xml:base="/development/serverless/Google-webp-how-many-less">&lt;h2 id=&quot;google-webp란&quot;&gt;Google WEBP란?&lt;/h2&gt;
&lt;p&gt;Google에서 독자적으로 만든 이미지 확장자를 뜻한다, 자세한 내용은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/WebP&quot;&gt;위키피디아&lt;/a&gt;에서 확인 가능하다.&lt;/p&gt;

&lt;p&gt;간단히 정리하자면 VP8 영상 코덱 기술을 활용해 이미지의 용량을 기존 .jepg에 비하여 약 10~80%까지 줄여주는 새로운 이미지 확장자를 말한다&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;그러나 2010년에 개발되어 벌써 8년이란 시간이 흘렀기에…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;용량을-신경써야하는-이유&quot;&gt;용량을 신경써야하는 이유&lt;/h2&gt;
&lt;p&gt;일반적인 블로그나, 웹서비스를 만든다면 물론 전혀 신경쓰지 않아도 될 부분일것 같다. 하지만 내가 지금 만들고 있는 서비스는 용량에 상당히 민감하기 때문에 나 역시 서버 비용을 부담해야하는 개인 개발자 입장에선 당연 용량을 신경 쓸 수밖에 없었다.&lt;/p&gt;

&lt;p&gt;이미지를 불러오거나 갤러리형식으로 만들 수 있으며 내가 올리고 싶은 이미지를 얼마든지 올릴 수 있는 그런 형식의 웹을 만들고 있는데,&lt;/p&gt;

&lt;p&gt;대략적인 예측으로는 썸네일의 다운로드 수가 만약 100이라면 실제로 클릭하는 이미지는 약 2~5개 내외가 될 것 같았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 .png확장자 기준 250*166의 이미지 용량이 약 115kb에 달했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;어쩌면-적을-수-있는-용량&quot;&gt;어쩌면 적을 수 있는 용량&lt;/h2&gt;
&lt;p&gt;115kb라고 해봤자 그렇게 큰 용량은 아님에 분명하다 하지만 이런 세세한 부분을 고민해야 아낄 수 있다고 생각했고&lt;/p&gt;

&lt;p&gt;.jpeg이미지 확장자로 동일 이미지를 변경해보았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;16kb약 1/7이 절약되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그러나-나는-이것도-만족하기-싫었다&quot;&gt;그러나 나는 이것도 만족하기 싫었다.&lt;/h2&gt;
&lt;p&gt;Node.js입문 이후 가장 오래 고민했던 것은&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;어떻게 하면 내 서버를 적게 쓰게 만들까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 고민이었다, 너무나도 싫었다 같은 데이터를 가져오기 위해 내 서버를 들락거리는 사용자를 보고만 있을 수 없었다..&lt;/p&gt;

&lt;p&gt;이게 내가 처음 웹에 입문해서 했던 고민이었다, 당시 내가 알고 있던 유일한 기술은 ‘쿠키’하나 였는데 (Local Storage를 몰랐다) 저장해야 할 텍스트가 약 3만자가 넘었다, 이를 저장하기 위해 gzip으로 압축하고 그것도 모자라서 쿠키 사이사이에 쪼개서 넣었던 기억이 난다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그만큼 내 서버를 조금만 쓰게 하고 싶었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 고민은 아직도 마찬가지다&lt;/p&gt;

&lt;h2 id=&quot;물론-서버는-이제-비싸지만은-않다&quot;&gt;물론 서버는 이제 비싸지만은 않다.&lt;/h2&gt;
&lt;p&gt;서버는 점점 저렴해지고, 점점 빨라지며 편해지기 까지 하고 있다. 이런 고민은 어쩌면 별거 아닌 고민일 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 앞서 언급했던것과 마찬가지로 내가 진행하는 프로젝트에선 썸네일이 가장 중요하지만 사용자는 직접적으로 썸네일을 다운받을 일이 없이 없기에 WEBP를 사용 하기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-webp는-동일-이미지-용량이-얼마나-줄었나&quot;&gt;그래서 WEBP는 동일 이미지 용량이 얼마나 줄었나?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/webp-how-many-less/one.png&quot; alt=&quot;비교 이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존 .png 확장자 대비 약 1/12나 줄어든것을 확인 할 수 있었다. .jpeg 확장자 대비해서도 약 4kb가 줄어들며 확실히 효과적이었다.&lt;/p&gt;</content><author><name></name></author><category term="개발" /><category term="aws" /><category term="serverless" /><category term="image" /><summary type="html">Google WEBP란? Google에서 독자적으로 만든 이미지 확장자를 뜻한다, 자세한 내용은 위키피디아에서 확인 가능하다.</summary></entry><entry><title type="html">aws를 사용해 serverless 프로젝트를 구성하며 느낀점</title><link href="/development/serverless/serverless-with-amazon-make-some-problem" rel="alternate" type="text/html" title="aws를 사용해 serverless 프로젝트를 구성하며 느낀점" /><published>2018-03-01T00:00:00+09:00</published><updated>2018-03-01T00:00:00+09:00</updated><id>/development/serverless/serverless-with-amazon-make-some-problem</id><content type="html" xml:base="/development/serverless/serverless-with-amazon-make-some-problem">&lt;h2 id=&quot;serverless&quot;&gt;Serverless?&lt;/h2&gt;
&lt;p&gt;서버리스란 말 그대로 서버가없는 서비스를 구성하는 프로젝트를 말한다 나는 현재 lambda를 사용해 개발을 하고 있으며 서버리스 프레임워크 serverless http를 이용해 개발을 하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;맞닦드린-문제들&quot;&gt;맞닦드린 문제들&lt;/h2&gt;
&lt;p&gt;이번은 es6(es2015)를 사용해 개발을 하고있다 특히 프론트도 vue로 하다보니 es6에 익숙해지는게 필요했다. babel을 사용해 dev프로젝트로 서비스를 가동하면 아무런 문제도 없던게 serverless-http사용해 aws lambda에 업로드하면 {forbidden:none} 에러를 뿜기 시작햇다.&lt;/p&gt;

&lt;p&gt;문제를 찾기위해 열심히 뒤졌지만 생각보다 관련 정보는 나오지 않았는데, 정말 사소한 이유였다 aws lambda는 es6문법에서 async await를 적용하지 않는다는 점이다,&lt;/p&gt;

&lt;p&gt;그렇다 모든 코드를 바꿔야했다.&lt;/p&gt;

&lt;p&gt;그 밖에도 mongodb의 연결이 안되어서 문제가 생긴경우도 있는데 이는 config파일을 제대로 읽지 못해 발생했다.&lt;/p&gt;

&lt;p&gt;exports.~~~라는 문법을 사용해서 해당 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;나름 엄격한 체제를 가지고 있기 때문에 기존에 가동되던 코드도 lambda에 업로드를 하면 안되는 경우가 너무 많았다. 아무튼 지금은 어느정도 중심을 잡은것 같다&lt;/p&gt;

&lt;h2 id=&quot;route53을-설정하기&quot;&gt;Route53을 설정하기.&lt;/h2&gt;
&lt;p&gt;쉽지 않은 일이었다. 그냥 배포된 주소로 접근하면 정말 잘 되던게 꼭 api.pikiidea.com이라고 쓰면 forbidden… 구글링 결과 api의 키를 줘야한다 뭘 해야한다 이걸 해야한다…..~~ 그러나 나의 실수는 serverless-http의 공식문서를 제대로 안 읽어서 생긴 문제였다.
&lt;a href=&quot;https://serverless.com/blog/serverless-api-gateway-domain/&quot;&gt;serverless-http에서 도메인을 설정하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 잘 읽어보면 us-east-01에서만 작동한다고 잠깐 언급이 되는데 이 부분을 제대로 읽지않아 하루를 왜 안돼지? 왜???? 도쿄리전 때문이라는 것을 알기 까지 생각보다 긴~시간을 보냈다.&lt;/p&gt;

&lt;h2 id=&quot;그럼에도-serverless&quot;&gt;그럼에도 serverless&lt;/h2&gt;
&lt;p&gt;서버리스를 처음 접한건 firebase functions를 사용하면서 였다, 당시에 간단한 정보를 크롤링해서 가져오는게 필요했는데 서버를 구성하기에는 귀찮고, 귀찮은것 만이 아니라 관리도 해야하기에 정말로 하기가 싫었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;그래서 발견하게 된것은 firebase functions&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;몇줄의 코드만으로 내가 원하는 기능을 추가할 수 있었다. 가령 이미지의 리사이즈나 업로드까지도 간편하게 추가가 가능했다.&lt;/p&gt;

&lt;p&gt;그 이후부터는 서버리스가 메인인 프로젝트를 해보고 싶었다.&lt;/p&gt;

&lt;h2 id=&quot;serverless의-유지보수는-간단하다&quot;&gt;serverless의 유지보수는 간단하다&lt;/h2&gt;
&lt;p&gt;예전에 vultr를 사용해서 서버를 가동할땐 간혹 오류가 생기면 서버가 뻣어버리는 경우가 잦았다. 나같은 개인 개발자는 서버까지 신경쓰며 거기다가 디자인까지 해야하는 경우인데 이런 경우가 생기면 그냥 프로젝트를 접고 싶은 마음이 점점 커져가고 포기한 프로젝트도 많아졌다.&lt;/p&gt;

&lt;p&gt;아마도 그래서 서버리스를 배워보고 싶었던 생각이 강했던것 같다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;aws 에서 serverless-http를 사용해서 구성하시려면 그냥 리전을 es-east-01에서 하세요.&lt;/p&gt;</content><author><name></name></author><category term="개발" /><category term="aws" /><category term="serverless" /><summary type="html">Serverless? 서버리스란 말 그대로 서버가없는 서비스를 구성하는 프로젝트를 말한다 나는 현재 lambda를 사용해 개발을 하고 있으며 서버리스 프레임워크 serverless http를 이용해 개발을 하고 있다.</summary></entry><entry><title type="html">일본에서 체크인 기능을 담은 웹을 개발했다</title><link href="/career/development-checkin" rel="alternate" type="text/html" title="일본에서 체크인 기능을 담은 웹을 개발했다" /><published>2018-01-22T00:00:00+09:00</published><updated>2018-01-22T00:00:00+09:00</updated><id>/career/development-checkin</id><content type="html" xml:base="/career/development-checkin">&lt;h2 id=&quot;일본은-왜&quot;&gt;일본은 왜?&lt;/h2&gt;
&lt;p&gt;문득 그냥 가고 싶었다 그래서 정말 이유 없이 왔다.&lt;/p&gt;

&lt;p&gt;그렇게 온 일본에서 처음으로 맡은 프로젝트 체크인 기능을 4개 국어로 만들어 달라.&lt;/p&gt;

&lt;p&gt;일본어, 중국어, 영어, 한국어까지
&lt;img src=&quot;/assets/img/postsImg/language-fplus.png&quot; alt=&quot;완성사진&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;필요-했던-부분&quot;&gt;필요 했던 부분&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;메일 서버&lt;/li&gt;
  &lt;li&gt;https 호스팅
    &lt;ul&gt;
      &lt;li&gt;firebase는 갓갓 호스팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이미지 서버&lt;/li&gt;
  &lt;li&gt;관리하기 쉬운 서버…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그니까 서버는 운용되는데 서버르 관리하기 꺼려한다고 전달 받았을때 바로 서버리스가 생각났다. 거기다가 firebase의 실시간 데이터베이스까지 사용한다면 걱정할게 없었다.&lt;/p&gt;

&lt;h2 id=&quot;메일&quot;&gt;메일&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mailgun.com/&quot;&gt;메일건&lt;/a&gt;을 이용해 메일을 발송하고 있다 처음 테스트 당시에는 google 계정으로 보냈었는데 생각보다 속도도 느리고 거디가다 찾아보니 발송 제한까지 있기에 따로 메일서버를 사용했다.&lt;/p&gt;

&lt;p&gt;가격은 상당히 저렴하며 월 10,000건 까지는 무료이기에 테스트에는 이정도의 조건은 없는것 같다.&lt;/p&gt;

&lt;p&gt;거기다가 딱히 어렵지 않게 적용할 수 있었고 STMP를 사용해 메일을 발송하면 끝 이었다.&lt;/p&gt;

&lt;p&gt;메일을 발송하는 부분은 &lt;a href=&quot;https://nodemailer.com/about/&quot;&gt;Nodemailer&lt;/a&gt;를 사용했다.&lt;/p&gt;

&lt;p&gt;그러나 메일 발송에서 별도의 서버를 운용하는게 꺼려진다고 하기에 firebase의 functions를 활용해 REST 형식의 웹으로 개발을하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;https-적용은&quot;&gt;https 적용은?&lt;/h2&gt;
&lt;p&gt;사실 나는 Nginx나 Apache서버를 사용해본 경험은 있지만 ssl을 적용하거나 했던일은 아예 없었다.&lt;/p&gt;

&lt;p&gt;그래서 위와 같은 개발환경에선 ssl을 적용하는게 얼마나 어려울지는 모르겠지만 REST 형식의 프론트엔드만 호스팅하면되기 때문에 상당히 간단했다.&lt;/p&gt;

&lt;p&gt;firebase의 정적웹 호스팅을 이용했는데 그냥 배포만 하면 자동으로 ssl을 적용해서 만들어줬기 때문에 따로 신경쓸 부분은 크게 없었다.&lt;/p&gt;

&lt;h2 id=&quot;언어는&quot;&gt;언어는?&lt;/h2&gt;
&lt;p&gt;언어는 JSON 형식으로 개발해 router로 나누어서 concat해서 각 언어에 맞게 불러오게 설계했다.&lt;/p&gt;

&lt;p&gt;제일 기본은 당연히 영어로 개발하고 해당 영어를 다른 국적의 직원들이 번역해줘서 상당히 빠르게 끝날 수 있었다.&lt;/p&gt;

&lt;p&gt;다음에 내가 다국적 서비스를 할 기회가 생긴다면 다시 한번 적용해볼만 한것 같다.&lt;/p&gt;

&lt;h2 id=&quot;그-외에&quot;&gt;그 외에&lt;/h2&gt;
&lt;p&gt;이미지 서버나 그외 부분 역시 firebase를 활용해 해결했다. 클라이언트가 특히 디자인에 많이 신경써달라고 했기 때문에 내가할 수 있는 최소한의 시간을 서버로 사용하고&lt;/p&gt;

&lt;p&gt;나머지는 프론트엔드 개발에 사용하게 되었다. 가령 사진을 촬영시 현재 보여지는 이미지가 다르게 나와야 한다거나 하는 자잘한 요구사항이 있었기에 생각보다 시간이 꽤 걸리는 작업이었다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며.&lt;/h2&gt;
&lt;p&gt;클라이언트가 자신이 무엇을 만들고 싶어하는지 모르는건 정말 개발자로 하여금 힘들게 한다, 자신이 무엇을 원하는지도 무엇을 만들어야 하는지도 모르는데… 더군다나 모자란 일본어로 소통하느냐고 나름 애를 먹었다.&lt;/p&gt;

&lt;p&gt;그러나 모자란 일본어로도 이 프로젝트를 정말 잘 끝냈기에 나름 자신감도 생기고 괜찮은 클라리언트(자신이 무엇을 만들고 싶어하는지도 모르지만 사람이 괜찮았다)를 만나 다행이었다.&lt;/p&gt;</content><author><name></name></author><category term="Node.js" /><category term="functions" /><category term="firebase" /><category term="vue.js" /><summary type="html">일본은 왜? 문득 그냥 가고 싶었다 그래서 정말 이유 없이 왔다.</summary></entry><entry><title type="html">노트북 거치대를 구매했다</title><link href="/life/new-laptop-stnad" rel="alternate" type="text/html" title="노트북 거치대를 구매했다" /><published>2018-01-21T00:00:00+09:00</published><updated>2018-01-21T00:00:00+09:00</updated><id>/life/new-laptop-stnad</id><content type="html" xml:base="/life/new-laptop-stnad">&lt;p&gt;일본에 와서 좋은점은 아마도 한국과는 다르게 직접 가서 사는것과 인터넷으로 주문하는게 그렇게 큰 차이가 나지 않기에 오프라인에서도 편하게 구매 할 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;기존에 쓰던 노트북 거치대는 처음에 살땐 정말 괜찮아 보였다.
&lt;img src=&quot;/assets/img/postsImg/nextstand/1.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;
각도 조절도 가능하고 무엇보다 튼튼하다는 생각이 들었고 한국에서도 잘 사용했다, 그러나 이것은 내가 평소에는 데스크탑을 사용하고 정말 가끔 노트북을 사용할때 이야기 였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/2.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;
일본에서 자취중인 지금은 책상이 예전과는 1/3도 안되는 수준 때문에 키보드의 자리가 남지않아 손목이 아파왔다 하루 10시간이 넘게 노트북을 바라보고 있는 입장에서 손목만 아프면 다행이겠지만 점점 목이 아파져오고 있었다.&lt;/p&gt;

&lt;p&gt;인터넷을 검색 하던중 괜찮은 거치대를 발견했다.&lt;/p&gt;

&lt;p&gt;오사카 덴덴타운을 돌아다닌 덕에 하나 구매를 할 수있었다.
바로 NEXT STAND의 제품인데 한국 돈으로 약 2만원에 구매 할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/3.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2만원의 가격을 가진 패키지 치고는 나름 깔끔하게 포장이 잘 되어있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/4.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;파우치가 함께 동봉되어 있다 제품의 무게는 약 500g이라는데 체감은 더 가볍게 느껴진다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/5.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제품의 옆면 약해보이는 느낌이 강했지만 직접 만져보면 튼튼하다는 생각이 들었다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/6.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제 거치대 위에 노트북을 올려놨을때 느낌 상당히 편하다 작업 공간도 많이 늘어났다 손목도 안아프고 목도 안아프다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/7.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;옆으로 조금만 넘어가도 떨어질것 같아 보이지만 오히려 그렇지 않다 지렛대의 원리로 쎄개 잡아주고 밑에는 스프링으로 잡아주기에 안전하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/9.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;
테스트를 해보고자 약 90도 까지 돌려봤지만 전혀 흔들림도 없었다 처음 노트북을 올릴때 ‘딱’소리가 나는데 아마 그 덕분인듯 하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/nextstand/8.jpeg&quot; alt=&quot;개봉사진&quot; /&gt;&lt;/p&gt;

&lt;p&gt;높이도 조절이 가능하다 나는 가장 높은위치에서 1단계 낮은 단계를 사용한다.&lt;/p&gt;

&lt;p&gt;방금 사와서 바로 작성하기에 아직은 정확히 모르지만 지금 잠깐 글을 쓰며 사용하면서 느끼는거지만 목이 정말 편하다&lt;/p&gt;</content><author><name></name></author><category term="일상" /><category term="지름" /><summary type="html">일본에 와서 좋은점은 아마도 한국과는 다르게 직접 가서 사는것과 인터넷으로 주문하는게 그렇게 큰 차이가 나지 않기에 오프라인에서도 편하게 구매 할 수 있다는 점이다.</summary></entry></feed>